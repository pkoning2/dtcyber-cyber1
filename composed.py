#!/usr/bin/env python3

import unicodedata
import sys
sys.stdout = open ("ptermkeytabs.h", "wt")

print ("// Generated by composed.py\n")

rom = ":abcdefg" \
      "hijklmno" \
      "pqrstuvw" \
      "xyz01234" \
      "56789+-*" \
      "/()$= ,." \
      "\u00F7[]%\u00D7\u21E6'\"" \
      "!;<>_?\u2AA2 " \
      "#ABCDEFG" \
      "HIJKLMNO" \
      "PQRSTUVW" \
      "XYZ\u02DC\u00A8^\u00B4`" \
      "\u2191\u2192\u2193\u2190" \
      "~\u03A3\u0394\u222A" \
      "\u2229{}&\u2260 |\u00B0" \
      "\u2263\u03B1\u03B2\u03B4" \
      "\u03BB\u03BC\u03C0\u03C1" \
      "\u03C3\u03C9\u2264\u2265" \
      "\u0398@\\ " \
      "\u2993\u2994\u00A9\u25AB" \
      "\u25C6\u2715\u02C7\u2195" \
      "\u25CB\u00B8"

acc = "`\u00b4^\u02DC\u00A8\u02c7\u00B8"
cacc = "\u0300\u0301\u0302\u0303\u0308\u030c\u0327"

nonacc = ''.join ([ c for c in rom if c not in acc ])

# ASCII (0..127 codes) to PLATO key code mapping.  If a single value
# appears, that is the key code.  If a tuple appears, that sequence of
# key codes is used.  "None" means this ASCII code doesn't correspond to
# a PLATO keycode.
asc2plato = [
	None,	0o022,	0o030,	0o033,
	0o031,	0o027,	0o064,	0o013,
	0o025,	None,	None,	None,
	0o035,	0o024,	None,	None,
	0o020,	0o034,	None,	0o032,
	0o062,	None,	None,	None,
	0o012,	0o021,	None,	None,
	None,	None,	None,	None,
	None,	0o176,	0o177,	(0o74, 0o044),
	0o044,	0o045,	(0o74, 0o016),	0o047,
	0o051,	0o173,	0o050,	0o016,
        0o137,	0o017,	0o136,	0o135,
	0o000,	0o001,	0o002,	0o003,
	0o004,	0o005,	0o006,	0o007,
	0o010,	0o011,	0o174,	0o134,
	0o040,	0o133,	0o041,	0o175,
	(0o74, 0o005),	0o141,	0o142,	0o143,
	0o144,	0o145,	0o146,	0o147,
	0o150,	0o151,	0o152,	0o153,
	0o154,	0o155,	0o156,	0o157,
	0o160,	0o161,	0o162,	0o163,
	0o164,	0o165,	0o166,	0o167,
	0o170,	0o171,	0o172,	0o042,
	(0o74, 0o135),	0o043,	(0o100, 0o74, 0o130),	0o046,
	(0o100, 0o74, 0o121),	0o101,	0o102,	0o103,
	0o104,	0o105,	0o106,	0o107,
	0o110,	0o111,	0o112,	0o113,
	0o114,	0o115,	0o116,	0o117,
	0o120,	0o121,	0o122,	0o123,
	0o124,	0o125,	0o126,	0o127,
	0o130,	0o131,	0o132,	(0o74, 0o042),
	(0o74, 0o151),	(0o74, 0o043),	(0o100, 0o74, 0o116),	None,
]

pastedasc2plato = list (asc2plato)
for i in range (32):
    if i != ord ("\n"):
        pastedasc2plato[i] = None
    else:
        pastedasc2plato[i] = 0o026        
pastedasc2plato[ord (" ")] = 0o100

# Dictionary to map non-ASCII Unicode values to PLATO key codes.  The
# representation of the PLATO key codes it the same as above.
u2plato = {
    "\u00a8" : (0o100, 0o74, 0o125),    # dieresis
    "\u00a9" : (0o74, 0o143),           # copyright
    "\u00b9" : (0o74, 0o117),        	# degree
    "\u00b4" : (0o100, 0o74, 0o105),    # acute accent
    "\u00b8" : (0o100, 0o74, 0o103),    # cedilla
    "\u00c5" : (0o74, 0o152),		# A with ring
    "\u00c6" : (0o74, 0o147),		# AE
    "\u00d7" : 0o012,        		# multiply
    "\u00d8" : (0o74, 0o150),		# O slash
    "\u00e5" : (0o74, 0o112),		# a with ring
    "\u00e6" : (0o74, 0o107),		# ae
    "\u00f7" : 0o013,        		# divide
    "\u00f8" : (0o74, 0o110),		# o slash
    "\u02c7" : (0o74, 0o126),        	# hacek
    "\u02dc" : (0o74, 0o116),        	# tilde
    "\u0300" : (0o74, 0o121),		# combining grave
    "\u0301" : (0o74, 0o105),         	# combining acute
    "\u0302" : (0o74, 0o130),		# combining circumflex (caret)
    "\u0303" : (0o74, 0o116),        	# combining tilde
    "\u0308" : (0o74, 0o125),         	# combining dieresis
    "\u030c" : (0o74, 0o126),        	# combining hacek
    "\u0327" : (0o74, 0o103),         	# combining cedilla
    "\u0396" : 0o057,        		# Delta
    "\u0398" : (0o74, 0o124),        	# Theta
    "\u03a3" : 0o056,        		# Sigma
    "\u03b1" : (0o74, 0o101),        	# alpha
    "\u03b2" : (0o74, 0o102),        	# beta
    "\u03b4" : (0o74, 0o104),        	# delta
    "\u03bb" : (0o74, 0o114),        	# lambda
    "\u03bc" : (0o74, 0o115),        	# mu
    "\u03c0" : (0o74, 0o120),        	# pi
    "\u03c1" : (0o74, 0o122),        	# rho
    "\u03c3" : (0o74, 0o123),        	# sigma
    "\u03c9" : (0o74, 0o127),        	# omega
    "\u2190" : (0o74, 0o141),        	# left arrow
    "\u2191" : (0o74, 0o167),        	# uparrow
    "\u2192" : (0o74, 0o144),        	# right arrow
    "\u2193" : (0o74, 0o170),        	# uparrow
    "\u2195" : (0o74, 0o137),        	# up/down
    "\u21e6" : 0o015,        		# assignment arrow
    "\u2229" : 0o053,        		# union
    "\u222a" : 0o052,        		# intersection
    "\u2260" : (0o74, 0o133),        	# not equal
    "\u2263" : (0o74, 0o173),        	# equivalent
    "\u2264" : (0o74, 0o040),        	# less/equal
    "\u2265" : (0o74, 0o041),        	# greater/equal
    "\u25ab" : (0o74, 0o157),        	# box
    "\u25c6" : (0o74, 0o146),        	# diamond
    "\u25cb" : (0o74, 0o012),        	# dot product
    "\u2715" : (0o74, 0o052),        	# cross product
    "\u2993" : (0o74, 0o000),        	# open embed
    "\u2994" : (0o74, 0o001),        	# close embed
    "\u2aa2" : (0o74, 0o006)        	# arrow (PLATO prompt)
    }

# Emit any accented characters that the normalizations rules say can be
# precomposed.  Also add them to the mappings from separate to combined.
sep = dict ()
for c in cacc:
    for n in nonacc:
        dc = n + c
        pc = unicodedata.normalize ("NFC", dc)
        if len (pc) == 1:
            o = ord (n)
            if o < len (asc2plato):
                k = asc2plato[o]
            else:
                k = u2plato[n]
            if not isinstance (k, tuple):
                k = (k, )
            k2 = u2plato[c]
            k += k2
            u2plato[pc] = k
            try:
                s = sep[c]
            except KeyError:
                s = sep[c] = dict ()
            s[k] = pc

def g (t, i):
    try:
        return "%04o" % t[i]
    except IndexError:
        return "None"
    
def emitkey (k):
    if isinstance (k, tuple):
        kc = ", ".join ([g (k, i) for i in range (4)])
        return "KEY (%s)" % kc
    if k is None:
        return "None"
    return "KEY (%04o, None, None, None)" % k

print ("const uint32_t asciiToPlato[128] = {")
for i in range (0, len (asc2plato), 2):
    l = ", ".join ([emitkey (asc2plato[i + j]) for j in range (2)])
    if i != len (asc2plato) - 2:
        l += ","
    print ("  ", l)
print ("};\n")

print ("const uint32_t pastedAsciiToPlato[128] = {")
for i in range (0, len (pastedasc2plato), 2):
    l = ", ".join ([emitkey (pastedasc2plato[i + j]) for j in range (2)])
    if i != len (pastedasc2plato) - 2:
        l += ","
    print ("  ", l)
print ("};\n")

print ("const ukey unicodeToPlato[] = {")
for k in sorted (u2plato):
    print ("  { 0x%04x, %s }," % (ord (k), emitkey (u2plato[k])))
print ("};")

