.PROC,CYBDEV.
.* 
.*  DEVELOPMENT LOAD PROCEDURE.
.* 
.*        IF FILE *LCONFIG/PLATOMF* DOES NOT EXIST,
.*                                             LOAD MASTOR.
.*        IF FILE *LCONFIG/PLATOMF* EXISTS, LOAD MASTORN.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        SYSEDIT IN CHANGES IF FILE *SYSEDT* EXISTS.
.* 
SETPUN.
GET(DEVPROC/NA)
IFE(FILE(DEVPROC,AS),SYSEDIT)
BEGIN(DEVPROC,DEVPROC) 
UNLOAD(*)
ENDIF(SYSEDIT) 
.* 
.*        SET UP FILE *CONFIGX* UNDER USER *PLATOMF*.
.*        IN THIS PROC, JUST PURGE *CONFIGX*.
.* 
SETPUN.
PURGE(CONFIGX/NA)
.* 
PACKNAM. 
CLEAR. 
.* 
SETPUN.
GET,LCONFIG/NA.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
SET(R1=0)
IFE(FILE(LCONFIG,EQ).EQ.0,MASTOR)
UNLOAD(*)
CONFIGX(V=CYBDEV)
DEVMFNX. 
MASTOR(CYBDEV) 
ELSE(MASTOR) 
UNLOAD(*)
CONFIGX(V=CYBDEV)
MASTORN. 
ENDIF(MASTOR)
DAYFILE. 
EXIT.
DMD.
DMD,0,100000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,CYBGOGO. 
.* 
.*  DEVELOPMENT LOAD PROCEDURE.
.* 
.*        IF FILE *LCONFIG/PLATOMF* DOES NOT EXIST,
.*                                             LOAD MASTOR.
.*        IF FILE *LCONFIG/PLATOMF* EXISTS, LOAD MASTORN.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        SYSEDIT IN CHANGES IF FILE *SYSEDT* EXISTS.
.* 
SETPUN.
GET(SYSEDT/NA) 
IFE(FILE(SYSEDT,AS),SYSEDIT) 
BEGIN(SYSEDT,SYSEDT) 
UNLOAD(*)
ENDIF(SYSEDIT) 
.* 
.*        SET UP FILE *CONFIGX* UNDER USER *PLATOMF*.
.*        IN THIS PROC, JUST PURGE *CONFIGX*.
.* 
SETPUN.
PURGE(CONFIGX/NA)
.* 
PACKNAM. 
CLEAR. 
.* 
SETPUN.
GET,LCONFIG/NA.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
SET(R1=0)
IFE(FILE(LCONFIG,EQ).EQ.0,MASTOR)
UNLOAD(*)
CONFIGX(V=GOGO)
MFNX.
MASTOR(GOGO) 
ELSE(MASTOR) 
UNLOAD(*)
CONFIGX(V=GOGO)
MASTORN. 
ENDIF(MASTOR)
DAYFILE. 
EXIT.
DMD.
DMD,0,100000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,CYBIS. 
.* 
.*  PRIME TIME LOAD PROCEDURE. 
.* 
.*        IF FILE *LCONFIG/PLATOMF* DOES NOT EXIST,
.*                                             LOAD MASTOR.
.*        IF FILE *LCONFIG/PLATOMF* EXISTS, LOAD MASTORN.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        SYSEDIT IN CHANGES IF FILE *SYSEDT* EXISTS.
.* 
SETPUN.
GET(SYSEDT/NA) 
IFE(FILE(SYSEDT,AS),SYSEDIT) 
BEGIN(SYSEDT,SYSEDT) 
UNLOAD(*)
ENDIF(SYSEDIT) 
.* 
.*        SET UP FILE *CONFIGX* UNDER USER *PLATOMF*.
.*        IN THIS PROC, JUST PURGE *CONFIGX*.
.* 
SETPUN.
PURGE(CONFIGX/NA)
.* 
PACKNAM. 
CLEAR. 
.* 
SETPUN.
GET,LCONFIG/NA.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
SET(R1=0)
IFE(FILE(LCONFIG,EQ).EQ.0,MASTOR)
UNLOAD(*)
CONFIGX(V=CYBIS) 
MFNX.
MASTOR(CYBIS)
ELSE(MASTOR) 
UNLOAD(*)
CONFIGX(V=CYBIS) 
MASTORN. 
ENDIF(MASTOR)
DAYFILE. 
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,CYBUPD.
.* 
.*  UPDATE INSTALLATION LOAD PROCEDURE.
.* 
.*        IF FILE *LCONFIG/PLATOMF* DOES NOT EXIST,
.*                                             LOAD MASTOR.
.*        IF FILE *LCONFIG/PLATOMF* EXISTS, LOAD MASTORN.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        SYSEDIT IN CHANGES IF FILE *SYSEDT* EXISTS.
.* 
SETPUN.
GET(SYSEDT/NA) 
IFE(FILE(SYSEDT,AS),SYSEDIT) 
BEGIN(SYSEDT,SYSEDT) 
UNLOAD(*,UPDATE) 
ENDIF(SYSEDIT) 
.* 
.*        SET UP FILE *CONFIGX* UNDER USER *PLATOMF*.
.*        ADD REPLACEMENT CONFIG PARAMETERS TO BE USED 
.*        WHEN DOING AN UPDATE INSTALLATION. 
.* 
SETPUN.
PURGE(CONFIGX/NA)
SAVE(UPDATE=CONFIGX) 
.* 
PACKNAM. 
CLEAR. 
.* 
SETPUN.
GET,LCONFIG/NA.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
SET(R1=0)
IFE(FILE(LCONFIG,EQ).EQ.0,MASTOR)
UNLOAD(*)
CONFIGX(V=CYBIS) 
MFNX.
MASTOR(CYBIS)
ELSE(MASTOR) 
UNLOAD(*)
CONFIGX(V=CYBIS) 
MASTORN. 
ENDIF(MASTOR)
DAYFILE. 
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
.* 
.DATA,UPDATE.
CPSPD=100.       GIVES MORE TIPS 
INSTL=1.         INDICATE CUT INSTALLATION 
~
.PROC,CYBINS.
.* 
.*  INITIAL INSTALLATION LOAD PROCEDURE. 
.* 
.*        IF FILE *LCONFIG/PLATOMF* DOES NOT EXIST,
.*                                             LOAD MASTOR.
.*        IF FILE *LCONFIG/PLATOMF* EXISTS, LOAD MASTORN.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        SYSEDIT IN CHANGES IF FILE *SYSEDT* EXISTS.
.* 
SETPUN.
GET(SYSEDT/NA) 
IFE(FILE(SYSEDT,AS),SYSEDIT) 
BEGIN(SYSEDT,SYSEDT) 
UNLOAD(*,INITIAL)
ENDIF(SYSEDIT) 
.* 
.*        SET UP FILE *CONFIGX* UNDER USER *PLATOMF*.
.*        ADD REPLACEMENT CONFIG PARAMETERS TO BE USED 
.*        WHEN DOING AN INITIAL INSTALLATION.
.* 
SETPUN.
PURGE(CONFIGX/NA)
SAVE(INITIAL=CONFIGX)
.* 
PACKNAM. 
CLEAR. 
.* 
SETPUN.
GET,LCONFIG/NA.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
SET(R1=0)
IFE(FILE(LCONFIG,EQ).EQ.0,MASTOR)
UNLOAD(*)
CONFIGX(V=CYBIS) 
MFNX.
MASTOR(CYBIS)
ELSE(MASTOR) 
UNLOAD(*)
CONFIGX(V=CYBIS) 
MASTORN. 
ENDIF(MASTOR)
DAYFILE. 
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
.* 
.DATA,INITIAL. 
CPSPD=100.       GIVES MORE TIPS 
INSTL=2.         INDICATE INITIAL INSTALLATION 
~
.PROC,PLATX,DIS=$*DIS$/DIS,AX=0/1,CP=,V=CYBIS,PN=PCEZ. 
.* 
.*        PLATO LOAD PROCEDURE.
.* 
.*          AX  - SPECIFIED FOR ALTERNATE EXECUTORS. 
.*          CP  = CONTROL POINT, DEFAULT IS HIGHEST. 
.*          V   = VERSION, THE DEFAULT IS CYBIS.  IF V 
.*                IS NOT CYBIS OR GOGO, IT IS THE USER 
.*                NUMBER FROM WHICH PBIN IS ATTACHED 
.*                (FROM PACK PCEZ IF V .EQ. GOGO; ELSE 
.*                FROM PACK SUPPORT).
.*          PN  = PBIN PACK, DEFAULT IS PCEZ.
.*          DIS - BRINGS UP DIS AT THE CONTROL POINT.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE,$CP$=$$,CPOINT2. 
PROUTE(PLAT) 
ELSE,CPOINT2.
PROUTE(PLAT,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,PLAT.
PLAT.
SETPR(70)
SETPUN.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
*
VERSX(L=PLATO,B=PBIN,M=PMAP,#V=V,#PN=PN) 
CONFIGX(#V=V)
MODE(1)
RFL(110000)
DIS. 
PLATO(AX)
DAYFILE. 
*
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,EXEC.
.* 
.*  LOAD 2ND EXECUTOR. 
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
CLASS(SC=SY) 
PLATX(AX)
REVERT.
~
.PROC,FRAMX,DIS=$*DIS$/DIS,CP=,V=CYBIS,PN=PCEZ.
.* 
.*        FRAMATTER LOAD PROCEDURE.
.* 
.*          CP  = CONTROL POINT, DEFAULT IS HIGHEST. 
.*          V   = VERSION, THE DEFAULT IS CYBIS.  IF V 
.*                IS NOT CYBIS OR GOGO, IT IS THE USER 
.*                NUMBER FROM WHICH FBIN IS ATTACHED 
.*                (FROM PACK PCEZ IF V .EQ. GOGO; ELSE,
.*                FROM PACK SUPPORT).
.*          PN  = FBIN PACK, DEFAULT IS PCEZ.
.*          DIS - BRINGS UP DIS AT THE CONTROL POINT.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE,$CP$=$$,CPOINT2. 
PROUTE(FRAM) 
ELSE,CPOINT2.
PROUTE(FRAM,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,FRAM.
FRAM.
SETPR(70)
SETPUN.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
*
VERSX(L=FRAMAT,B=FBIN,M=FMAP,#V=V,#PN=PN)
MODE(1)
RFL(30000) 
DIS. 
FRAMAT.
IFE(R1.EQ.050323B,RELOAD)
DAYFILE. 
ROUTE(OUTPUT,DC=LP)
FRAMX(#V=V,#PN=PN) 
ENDIF(RELOAD)
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,CONDX,DIS=$*DIS$/DIS,CP=,PR=,V=CYBIS,PN=PCEZ.
.* 
.*        CONDENSOR LOAD PROCEDURE.
.* 
.*          CP  = CONTROL POINT, DEFAULT IS HIGHEST. 
.*          PR  = PRIORITY FOR CONDENSOR TO RUN (1-72B)
.*                (DEFAULT IS 72B SET BY CONDENSOR ITSELF) 
.*          V   = VERSION, THE DEFAULT IS CYBIS.  IF V 
.*                IS NOT CYBIS OR GOGO, IT IS THE USER 
.*                NUMBER FROM WHICH CBIN IS ATTACHED 
.*                (FROM PACK PCEZ IF V .EQ. GOGO; ELSE,
.*                FROM PACK SUPPORT).
.*          PN  = CBIN PACK, DEFAULT IS PCEZ.
.*          DIS - BRINGS UP DIS AT THE CONTROL POINT.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
CLASS(SC=SY) 
IFE,$CP$=$$,CPOINT2. 
PROUTE(COND) 
ELSE,CPOINT2.
PROUTE(COND,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,COND.
COND.
SETPR(70)
IFE($V$ .EQ. $CYBIS$,USER) 
SETPUN.
ENDIF(USER)
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
* MAX CM FL ALLOWED TO AVOID DEADLOCK. 
MFL(CM=104000) 
*
VERSX(L=CONDEN,B=CBIN,M=CMAP,#V=V,#PN=PN)
MODE(1)
RFL(40000) 
DIS. 
IFE,($PR$ .NE. $$),COND. 
CONDEN(PR).
ELSE(COND) 
CONDEN.
ENDIF(COND)
*
*  IF ECS ERROR, PRINT DAYFILE AND RELOAD. 
*
IFE(R1.EQ.050323B,RELOAD)
DAYFILE. 
ROUTE(OUTPUT,DC=LP)
CONDX(#V=V,#PN=PN,#PR=PR)
ENDIF(RELOAD)
*
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,PLFX,DIS=$*DIS$/DIS,CP=,V=CYBIS,PN=PCEZ. 
.* 
.*        PLF LOAD PROCEDURE.
.* 
.*        PARAMETERS.
.* 
.*          CP  = CONTROL POINT NUMBER, DEFAULT IS HIGHEST.
.*          V   = VERSION, THE DEFAULT IS CYBIS.  IF V 
.*                IS NOT CYBIS OR GOGO, IT IS THE USER 
.*                NUMBER FROM WHICH PLFBIN IS ATTACHED 
.*                (FROM PACK PCEZ IF V .EQ. GOGO; ELSE,
.*                FROM PACK SUPPORT).
.*          PN  = PLFBIN PACK, DEFAULT IS PCEZ.
.*          DIS - BRINGS UP DIS AT THE CONTROL POINT.
.* 
.*        EXAMPLES.
.* 
.*          X.PLFX.          LOAD PRIME TIME PLF.
.* 
.*          X.PLFX(V=GOGO)   LOAD GOGO PLF.
.* 
.*          X.PLFX(V=TEST)   LOAD PLF FROM USER NUMBER TEST. 
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE,$CP$=$$,CPOINT2. 
PROUTE(PLFJOB) 
ELSE,CPOINT2.
PROUTE(PLFJOB,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,PLFJOB.
PLF. 
SETPR(70)
SETPUN.
CLASS(SC=SY) 
SETPR(41)
SETTL(*) 
SETASL(*)
SETJSL(*)
NORERUN. 
MODE(7)
*
IFE($V$.NE.$CYBIS$,VERSION)
VERSX(L=PLFBIN,B=PLFBIN,M=PLFMAP,#V=V,#PN=PN)
GTR(PLFBIN,PLF,,,S,NA)ABS/PLF-ULIB/PLF 
UNLOAD(PLFBIN) 
ENDIF(VERSION) 
*
IFE(.NOT.FILE(PLF,AS),CYBIS) 
COMMON(SYSTEM) 
GTR(SYSTEM,PLF)ABS/PLF-ULIB/PLF
UNLOAD(SYSTEM) 
ENDIF(CYBIS) 
*
*UNLOAD(*,PLF,MAP) 
RFL(12000) 
DIS. 
PLF. 
*
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,DSNX,CP=,V=CYBIS.
.* 
.*        DSN LOAD PROCEDURE.
.* 
.*        CP = CONTROL POINT, DEFAULT IS HIGHEST.
.*        V  = VERSION (DEFAULT IS *CYBIS*), BUT IT DOES 
.*             NOT MATTER BECAUSE THERE IS ONLY ONE VERSION. 
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE,$CP$=$$,CPOINT2. 
PROUTE(DSNJOB) 
ELSE,CPOINT2.
PROUTE(DSNJOB,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,DSNJOB.
DSN. 
SETPR(70)
SETPUN.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
DSN. 
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,NPDX,EQ=0. 
.* 
.*        DUMP THE DSN 2550
.* 
.*        ENTRY  EQ = EQUIPMENT NUMBER; IF 0, IT WILL DUMP 
.*                 THE FIRST ONE IT FINDS STARTING AT THE
.*                 HIGHEST NUMBERED EQUIPMENT. 
.* 
NPUDMP(#EQ=EQ) 
NPUDPP.
REVERT.
~
.PROC,PNIX,DIS=$*DIS$/DIS,CP=,V=CYBIS,PN=PCEZ,FAMILY=,ORD=1. 
.* 
.*        PNI LOAD PROCEDURE.
.* 
.*          CP  = CONTROL POINT, DEFAULT IS HIGHEST. 
.*          V   = VERSION, THE DEFAULT IS CYBIS.  IF V 
.*                IS NOT CYBIS OR GOGO, IT IS THE USER 
.*                NUMBER FROM WHICH PNI IS ATTACHED
.*                (FROM PACK PCEZ IF V .EQ. GOGO; ELSE,
.*                FROM PACK SUPPORT).
.*          PN  = PNI PACK, DEFAULT IS PCEZ. 
.*          DIS - BRINGS UP DIS AT THE CONTROL POINT.
.*          ORD = PNI ORDINAL (DEFAULT = 1)
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE,$CP$=$$,CPOINT2. 
PROUTE(PNIJOB) 
ELSE,CPOINT2.
PROUTE(PNIJOB,#CP=CP)
ENDIF,CPOINT2. 
REVERT.
.* 
.DATA,PNIJOB.
PNIJOB.
SETPR(70)
SETPUN.
CLASS(SC=SY) 
NORERUN. 
SETTL(*) 
SETASL(*)
SETJSL(*)
.* 
.* 
.* PNIDBG IS FOR ROUTING AIP TRACE FOR PROCESSING
.* 
.* 
NOTE,PNIDBG,NR./PNIBUG.
NOTE,PNIDBG,NR./SUI,377777.
NOTE,PNIDBG,NR./SETTL,*. 
NOTE,PNIDBG,NR./SETASL,*.
NOTE,PNIDBG,NR./COPYEI,INPUT,ZZZZZDN.
NOTE,PNIDBG,NR./DLFP(I=0)
NOTE,PNIDBG,NR./ROUTE,OUTPUT,DC=PR.
REWIND,PNIDBG. 
PACK,PNIDBG. 
.* 
.* 
.*  END OF PNIDBG
.* 
.* 
VERSX(L=PNI,B=PNIBIN,M=PNIMAP,#V=V,#PN=PN) 
UNLOAD(*,PNI,MAP,PNIDBG) 
#FAMILY=FAMILY.
.*ATTACH(ISTLF00)              IST3
.*ATTACH(ISTLF01)              IST2/IST3 
.*ATTACH(ISTLF02/NA) 
.*ATTACH(ISTLF03)              IST1
.*ATTACH(ISTLF04/NA) 
.*ATTACH(ISTLF05/NA) 
.*ATTACH(ISTLF06/NA) 
.*ATTACH(ISTLF07/NA) 
.*ATTACH(ISTLF08)              VIKING 721
.*ATTACH(ISTLF09/NA) 
.*.* 
IFE,($V$.NE.$CYBDEV$),CYBDEV.
NOEXIT.
ATTACH(PNILOCK/M=W)
IFE(.NOT.FILE(PNILOCK,AS),PNIDF) 
DEFINE(PNILOCK)
ENDIF(PNIDF) 
ENDIF(CYBIS) 
ONEXIT.
IFE(FILE(PNILOCK,AS),RUNPNI) 
DIS. 
PNI(ORD) 
ENDIF(RUNPNI)
ELSE(CYBDEV) 
DIS. 
PNI(ORD) 
ENDIF(CYBDEV)
EXIT.
DMD.
DMD,0,150000.
DAYFILE. 
ROUTE(OUTPUT)
~
.PROC,VERSX,L,B,M=,V=CYBIS,PN=PCEZ.
.* 
.*        GET PROPER VERSION OF LOAD FILE. 
.* 
.*        L  = LOCAL FILE NAME.
.*        B  = DIRECT ACCESS BINARY FILE.
.*        M  = DIRECT ACCESS LOAD MAP FILE.
.*        V  = VERSION, DEFAULT IS CYBIS.
.*        PN = PACK NAME FOR GOGO BINARIES (PERSONAL 
.*             BINARIES ARE ON PACK SUPPORT).
.* 
.*        IF V .EQ. CYBIS, DO NOTHING. 
.*        IF V .NE. GOGO, ATTACH L=B FROM UN=V, PN=SUPPORT.
.*        IF V .EQ. GOGO, ATTACH L=B FROM UN=PLATO, PN=PCEZ. 
.* 
.*        IF THE FILE IS NOT AVAILABLE FROM UN=V, IT 
.*        IS ATTACHED FROM UN=CYBIS.  IF IT IS ALSO NOT
.*        AVAILABLE FROM UN=PLATO, NOTHING IS DONE.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
GET,LCONFIG/NA.
IFE($V$.EQ.$CYBIS$,CYBIS)
IFE($L$.EQ.$CONDEN$,CONDEN)
*   KEEP CONDEN OVERLAYS IN LOCAL FILE FOR *CDISK*.
COMMON(SYSTEM) 
GTR(SYSTEM,CONDEN,U)ABS/CONDEN,ULIB/CONDEN 
UNLOAD(SYSTEM) 
ENDIF(CONDEN)
REVERT.
ENDIF(CYBIS) 
.* 
UNLOAD(MAP)
USER(CYBIS,ATHENA)
.* 
IFE,($V$.EQ.$CYBDEV$),CYBDEV.
IFE,($B$.EQ.$MBIN$),MBIN.
ATTACH(B=MBINDEV/NA) 
ENDIF(MBIN)
IFE,($B$.EQ.$PBIN$),PBIN.
ATTACH(B=PBINDEV/NA) 
ENDIF(PBIN)
IFE,($B$.EQ.$FBIN$),FBIN.
ATTACH(B=FBINDEV/NA) 
ENDIF(FBIN)
IFE,($B$.EQ.$PNIBIN$),PNIBIN.
ATTACH(B=PNIDEV/NA)
ENDIF(PNIBIN)
IFE,($B$.EQ.$CBIN$),CBIN.
ATTACH(B=CBINDEV/NA) 
ENDIF(CBIN)
.* 
ELSE(CYBDEV) 
ATTACH(B/NA,R=DQ)
ENDIF(CYBDEV)
FAMILY.
.* 
IFE($L$.NE.$B$,LSAB) 
UNLOAD(L)
COPY(B,L)
REWIND(L)
UNLOAD(B)
ENDIF(LSAB)
IFE($M$.NE.$$,MAP) 
ATTACH(M/NA,R=DQ)
COPY(M,MAP)
REWIND(MAP)
UNLOAD(M)
ENDIF(MAP) 
SETPUN.
.* 
.*        IF FILE STILL NOT ATTACHED AFTER ALL THIS WORK,
.*        THEN END JOB WITHOUT EXIT PROCESSING.
.* 
IFE(.NOT.FILE(L,AS),CYBIS) 
*  BINARY FILE NOT FOUND.
DAYFILE. 
EXIT.
EXIT.
ENDIF(CYBIS) 
.* 
REVERT.
~
.PROC,CONFIGX,V=CYBIS. 
.* 
.*  GET THE CONFIGURATION FILE.
.* 
.*        IF V .EQ. CYBIS, GET TEXT/CONFIG FROM SYSTEM.
.*        IF V .NE. CYBIS, GET FILE GOGOCON. 
.* 
.*        IF INDIRECT ACCESS FILE *CONFIGX* EXISTS UNDER 
.*        USER INDEX 377773B, APPEND ITS CONTENTS TO THE 
.*        RETRIEVED CONFIGURATION FILE.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
IFE($V$.EQ.$CYBDEV$,CYBDEV)
SETPUN.
GET(CONFIG=DEVCFIG)
REVERT.
ENDIF(CYBDEV)
.* 
IFE($V$.NE.$CYBIS$,GOGOCON)
SETPUN.
GET(CONFIG=GOGOCON/NA) 
ENDIF(GOGOCON) 
.* 
IFE(.NOT.FILE(CONFIG,AS),CONFIG) 
COMMON(SYSTEM) 
GTR(SYSTEM,CONFIG)TEXT/CONFIG
UNLOAD(SYSTEM) 
ENDIF(CONFIG)
.* 
sui(377777).
GET(C=CONFIGX/NA)
setpun.
IFE(FILE(C,AS),ADD)
SKIPEI(CONFIG) 
COPYEI(C,CONFIG) 
REWIND(*)
PACK(CONFIG) 
UNLOAD(C)
ENDIF(ADD) 
.* 
GET(LCONFIG/NA)
IFE(FILE(LCONFIG,AS),ADDLOC) 
SKIPEI(CONFIG) 
COPYEI(LCONFIG,CONFIG) 
*UNLOAD(LCONFIG) 
REWIND(CONFIG) 
PACK(CONFIG) 
REWIND(CONFIG) 
ENDIF(ADDLOC)
.* 
REVERT.
~
.PROC,EMDTAPE,DF=PLATEM,VSN=PLATEM,ABTBUSY=YES.
.* 
.*        DUMP JOBS EM TO DISK AND SUBMIT JOB TO COPY
.*        JOBS CM, LISTING AND EM DUMPS TO TAPE. 
.* 
.*        DF      = DUMP FILE. 
.*        VSN     = TAPE VSN.
.*        ABTBUSY = YES - ABORT IF EM DUMP FILE BUSY 
.*                  NO  - WAIT FOR EM DUMP FILE, THEN EXIT 
.*                  (SEE PSR 16895 FOR THE REASON FOR THIS)
.* 
.*        DUMP FORMAT';
.*        EACH JOB HAS A FILE ON THE DUMP TAPE FOR ITS 
.*        OUTPUT RECORDS AND CM DUMP RECORDS IN THE
.*        FOLLOWING ORDER -
.* 
.*          MASTOR(N)
.*          PLATO
.*          EXEC1
.*          EXEC2
.*          FRAMAT 
.*          FORMAT 
.*          CONDENSOR
.*          CONDENSOR1 
.*          CONDENSOR2 
.*          PLF
.*          PNI
.* 
.*        EACH FILE IS COMPOSED OF THE FOLLOWING RECORDS - 
.* 
.*          DAYFILE
.*          LOAD MAP (NOT USED BY MASTOR(N)) 
.*          EFR DUMP (PLATO, FRAMAT/FORMAT ONLY) 
.*          EXCHANGE PACKAGE DUMP
.*          ID RECORD FOR CM DUMP
.*          CM RECORDS 
.* 
.*        THESE FILES ARE FOLLOWED BY THE EM DUMP FILE.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        FORMAT CM DUMP.
.* 
FORMCMD. 
.* 
.*        DUMP JOBS EM 
.* 
.*        DEFINE THE FILE IF IT DOES NOT ALREADY EXIST.  THE 
.*        ATTACH WILL ASSURE THAT A SECOND ATTEMPT TO DUMP 
.*        TO THE SAME FILE WILL ABORT. 
.* 
.*        ALSO, ALWAYS CLEAR ERROR STATUS IN CASE OLD FILE 
.*        IS BAD.
.* 
ONEXIT.
SETPUN.
PACKNAM. 
CHANGE(DF/CE,NA) 
DEFINE(DF/NA)
IFE($ABTBUSY$ = $YES$, ATT)
ATTACH(DF/M=W) 
ELSE(ATT)
NOEXIT.
ATTACH(DF/M=W) 
ONEXIT.
IFE(.NOT.(FILE(DF,AS)),NODMP)
.*  SOMEONE ELSE HAS THE DUMP FILE ATTACHED, 
.*  WAIT UNTIL IT IS NON-BUSY, THEN SKIP THE 
.*  DUMP BECAUSE IT HAS ALREADY BEEN DONE. 
ATTACH(DF/M=W,NA)  ROLLOUT UNTIL FILE AVAILABLE
SKIP(ROUTE)
ENDIF(NODMP) 
ENDIF(ATT) 
.* 
.*        DUMP EXTENDED MEMORY AND THEN RELEASE THE FILE.
.* 
EMDMP(DF,0,77777)
UNLOAD(DF) 
.* 
.*        SUBMIT JOB TO COPY DUMPS TO TAPE.
.*        THERE IS A COPY OF THE FOLLOWING IN *PLATX*
.* 
ENDIF(ROUTE) 
ROUTE(EMDT,DC=IN,OT=SYOT)
.* 
REVERT.
.* 
EXIT.
.* 
.*        SUBMIT JOB TO COPY CM DUMP TO TAPE.
.* 
ROUTE(EMDT,DC=IN,OT=SYOT)
REVERT.
.* 
.DATA,EMDT.
EMDTJOB. 
COPYPD(#DF=DF) 
~
.PROC,FORMCMD. 
.* 
.*        FORMAT JOBS CM AND OUTPUT DUMPS. 
.* 
.*        ON ENTRY, *LDMAP* IS EXPECTED TO HOLD THE JOBS 
.*        LOAD MAP (IF ANY), *XP* IS EXPECTED TO HOLD
.*        THE JOBS EXCHANGE PACKAGE DUMP AND *EFR* IS
.*        EXPECTED TO HOLD THE JOBS EFR DUMP (IF ANY). 
.*        ALSO, THE JOBS CM DUMP FILE IS ATTACHED AS 
.*        *CMDUMP*.
.* 
.*        *CONDX* EXPECTS *CMFILE* TO STILL BE ASSIGNED
.*        ON EXIT FROM *EMDTAPE*, WHICH CALLS THIS PROC. 
.* 
.*        SEE PROC/EMDTAPE FOR THE FORMAT OF EACH DUMP FILE. 
.* 
NOEXIT.
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        FORMAT JOBS CM AND OUTPUT LISTINGS 
.* 
REWIND(OUTPUT) 
DAYFILE. 
PACK(OUTPUT,DFLIST)
RETURN(OUTPUT) 
REWIND(DFLIST,LDMAP,EFR,XP,CMFILE,CMDUMP)
COPYBR(DFLIST,CMDUMP)
*
IFE(FILE(LDMAP,AS),W1) 
COPYBR(LDMAP,CMDUMP) 
ELSE(W1) 
WRITER(CMDUMP) 
ENDIF(W1)
*
IFE(FILE(EFR,AS),W2) 
COPYBR(EFR,CMDUMP) 
ELSE(W2) 
WRITER(CMDUMP) 
ENDIF(W2)
*
IFE(FILE(XP,AS),W3)
COPYBR(XP,CMDUMP)
ELSE(W3) 
WRITER(CMDUMP) 
ENDIF(W3)
*
IFE(FILE(CMFILE,AS),W4)
COPYBF(CMFILE,CMDUMP)
ELSE(W4) 
WRITER(CMDUMP) 
ENDIF(W4)
UNLOAD(CMDUMP) 
*
*  PRINT XP AND DAYFILE. 
*
IFE(FILE(XP,AS),W9)
REWIND(OUTPUT,XP)
COPYBF(XP,OUTPUT)
ELSE(W9) 
WRITER(OUTPUT) 
ENDIF(W9)
~
.PROC,COPYPD,DF=PLATEM,VSN=PLATEM. 
.* 
.*        COPY PLATO DUMP FILES TO TAPE
.* 
.*        DF = EM DUMP FILE NAME (DEFAULTS TO *PLATEM*)
.*        VSN = DUMP TAPE VSN (DEFAULTS TO *PLATEM*) 
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
SETPUN.
PACKNAM. 
SETPR(41)
.* 
.*  USE FILE *DUMPLOK* AS AN INTERLOCK TO ALLOW ONLY 
.*  ONE COPY OF THE TAPE COPY JOB ON EACH MAINFRAME. 
.* 
NOEXIT.
ATTACH(DUMPLOK/M=W)
IFE(.NOT.(FILE(DUMPLOK,AS)),LOCK)
DEFINE(DUMPLOK)
IFE(.NOT.(FILE(DUMPLOK,AS)),LOCK)
*  DUMP-TO-TAPE JOB IS ALREADY RUNNING.
REVERT.
ENDIF(LOCK)
ONEXIT.
.* 
WAIT. FOR PLATO CRASH DUMPS TO FINISH. 
.* 
.*        ATTACH ALL CM DUMPS (IF IT DOES NOT EXIST, 
.*        CONTINUE.  IF BUSY, WAIT.) 
.* 
WHILE(0.EQ.0,LOOP) 
WAIT. MAKE SURE A TAPE DRIVE IS *ON*, THEN *GO*. 
BLANK(#VSN=VSN)
LABEL(T,#VSN=VSN,F=I,W,PO=FW)
ATTACH(MASTCM/M=W,NA)
ATTACH(EX0CM/M=W,NA) 
ATTACH(EX1CM/M=W,NA) 
ATTACH(EX2CM/M=W,NA) 
ATTACH(FRAMCM/M=W,NA)
ATTACH(FORMCM/M=W,NA)
ATTACH(CND0CM/M=W,NA)
ATTACH(CND1CM/M=W,NA)
ATTACH(CND2CM/M=W,NA)
ATTACH(PLFCM/M=W,NA) 
ATTACH(PNICM/M=W,NA) 
ATTACH(DF/NA)
.* 
.*  FOLLOWING IS SO SUBSEQUENT DUMP PROCS WILL 
.*  NOT ABORT ON ATTEMPTING TO ATTACH EM DUMP
.*  FILE WHILE IT IS BEING COPIED TO TAPE. 
.* 
IFE(FILE(DF,AS),W0)
PURGE(EMDUMP/NA) 
CHANGE(EMDUMP=DF/NA) 
ELSE(W0) 
ATTACH(DF=EMDUMP/NA) 
ENDIF(W0)
REWIND(*)
.* 
IFE(FILE(MASTCM,AS),W1)
COPYBF(MASTCM,T) 
ELSE(W1) 
WRITEF(T)
ENDIF(W1)
.* 
IFE(FILE(EX0CM,AS),W2) 
COPYBF(EX0CM,T)
ELSE(W2) 
WRITEF(T)
ENDIF(W2)
.* 
IFE(FILE(EX1CM,AS),W3) 
COPYBF(EX1CM,T)
ELSE(W3) 
WRITEF(T)
ENDIF(W3)
.* 
IFE(FILE(EX2CM,AS),W4) 
COPYBF(EX2CM,T)
ELSE(W4) 
WRITEF(T)
ENDIF(W4)
.* 
IFE(FILE(FRAMCM,AS),W5)
COPYBF(FRAMCM,T) 
ELSE(W5) 
WRITEF(T)
ENDIF(W5)
.* 
IFE(FILE(FORMCM,AS),W6)
COPYBF(FORMCM,T) 
ELSE(W6) 
WRITEF(T)
ENDIF(W6)
.* 
IFE(FILE(CND0CM,AS),W7)
COPYBF(CND0CM,T) 
ELSE(W7) 
WRITEF(T)
ENDIF(W7)
.* 
IFE(FILE(CND1CM,AS),W8)
COPYBF(CND1CM,T) 
ELSE(W8) 
WRITEF(T)
ENDIF(W8)
.* 
IFE(FILE(CND2CM,AS),W9)
COPYBF(CND2CM,T) 
ELSE(W9) 
WRITEF(T)
ENDIF(W9)
.* 
IFE(FILE(PLFCM,AS),W10)
COPYBF(PLFCM,T)
ELSE(W10)
WRITEF(T)
ENDIF(W10) 
.* 
IFE(FILE(PNICM,AS),W11)
COPYBF(PNICM,T)
ELSE(W11)
WRITEF(T)
ENDIF(W11) 
.* 
COPYEI(DF,T) 
.* 
.*  PURGE ONLY THOSE FILES CURRENTLY ASSIGNED. 
.* 
IFE(FILE(MASTCM,AS),P1)
PURGE(MASTCM/NA) 
ENDIF(P1)
.* 
IFE(FILE(EX0CM,AS),P2) 
PURGE(EX0CM/NA)
ENDIF(P2)
.* 
IFE(FILE(EX1CM,AS),P3) 
PURGE(EX1CM/NA)
ENDIF(P3)
.* 
IFE(FILE(EX2CM,AS),P4) 
PURGE(EX2CM/NA)
ENDIF(P4)
.* 
IFE(FILE(FRAMCM,AS),P5)
PURGE(FRAMCM/NA) 
ENDIF(P5)
.* 
IFE(FILE(FORMCM,AS),P6)
PURGE(FORMCM/NA) 
ENDIF(P6)
.* 
IFE(FILE(CND0CM,AS),P7)
PURGE(CND0CM/NA) 
ENDIF(P7)
.* 
IFE(FILE(CND1CM,AS),P8)
PURGE(CND1CM/NA) 
ENDIF(P8)
.* 
IFE(FILE(CND2CM,AS),P9)
PURGE(CND2CM/NA) 
ENDIF(P9)
.* 
IFE(FILE(PLFCM,AS),P10)
PURGE(PLFCM/NA)
ENDIF(P10) 
.* 
IFE(FILE(PNICM,AS),P11)
PURGE(PNICM/NA)
ENDIF(P11) 
.* 
IFE(FILE(DF,AS),P13) 
PURGE(EMDUMP/NA) 
ENDIF(P13) 
.* 
.* SO TAPE CANNOT BE OVERWRITTEN BY LATER DUMP.
UNLOAD(T)
EXIT.
IFE(EF .EQ. ODE,NODMP) 
.* 
.*  PURGE ALL DUMP FILES.
.* 
PURGE(MASTCM/NA) 
PURGE(EX0CM/NA)
PURGE(EX1CM/NA)
PURGE(EX2CM/NA)
PURGE(FRAMCM/NA) 
PURGE(FORMCM/NA) 
PURGE(CND0CM/NA) 
PURGE(CND1CM/NA) 
PURGE(CND2CM/NA) 
PURGE(PLFCM/NA)
PURGE(PNICM/NA)
PURGE(DF/NA) 
PURGE(EMDUMP/NA) 
EXIT.
ENDIF(NODMP) 
UNLOAD(*,DUMPLOK)
ENDW(LOOP) 
EXIT.
~
.PROC,PDCAT,TID=,VSN=PLATEM. 
.* 
.*        THIS PROCEDURE PRODUCES A CATALOG OF THE CONTENTS
.*        OF A PLATO-FORMATTED DUMP TAPE ON FILE ',OUTPUT',. 
.* 
.*        CONTROL STATEMENT FORMAT - 
.*               'P'D'C'A'T(TID) 
.*               'P'D'C'A'T('T'I'D=TID,'V'S'N=VSN) 
.* 
.*        PARAMETERS - 
.*               TID = EXTERNAL TAPE IDENTIFIER
.*               VSN = VSN FOR TAPE (DEFAULT IS ',PLATEM',)
.* 
.*        NOTE - THIS PROCEDURE ASSUMES THE DUMP TO BE 
.*        CATALOGED IS TO BE REQUESTED UNLESS A LOCAL FILE 
.*        NAMED ',TAPE', EXISTS.  FILE ',TAPE', IS RETURNED IF 
.*        REQUESTED BY THIS PROCEDURE.  IF FILE ',TAPE', WAS 
.*        NOT REQUESTED BY THIS PROCEDURE, IT IS REWOUND.
.* 
IFE(.NOT.(FILE(TAPE,AS)),GETT) 
WAIT.  MOUNT TAPE TID
LABEL(TAPE,#F=I,#VSN=VSN,PO=FR)
.*  NEED FOLLOWING TO SET EOF STATUS 
.*  FOR *FILE* FUNCTION TO FIRST RECORD/EOF. 
WRITEF(T)
COPYEI(TAPE,T) 
UNLOAD(TAPE) 
.* 
ELSE(GETT) 
REWIND(TAPE) 
WRITEF(T)
COPYEI(TAPE,T) 
REWIND(TAPE) 
ENDIF(GETT)
.* 
REWIND(T)
SKIPF(T,1) 
NOTE(DISK,NR)/CATALOG OF DUMP TAPE TID.
NOTE(DISK,NR)/ 
NOTE(DISK,NR)/ 
SET(R1=0)
.* 
WHILE(R1.LE.10,LOOP) 
.* 
.*  SKIP EOF RECORD. 
SKIPR(T) 
IFE(.NOT.(FILE(T,EOF)),EMPTY)
.* 
IFE(R1=0,TITLE)
NOTE(DISK,NR)/MASTOR(N)
ELSE(TITLE)
IFE(R1=1,TITLE)
NOTE(DISK,NR)/PLATO
ELSE(TITLE)
IFE(R1=2,TITLE)
NOTE(DISK,NR)/FIRST EXECUTOR 
ELSE(TITLE)
IFE(R1=3,TITLE)
NOTE(DISK,NR)/SECOND EXECUTOR
ELSE(TITLE)
IFE(R1=4,TITLE)
NOTE(DISK,NR)/FRAMAT 
ELSE(TITLE)
IFE(R1=5,TITLE)
NOTE(DISK,NR)/FORMAT 
ELSE(TITLE)
IFE(R1=6,TITLE)
NOTE(DISK,NR)/FIRST CONDENSOR
ELSE(TITLE)
IFE(R1=7,TITLE)
NOTE(DISK,NR)/SECOND CONDENSOR 
ELSE(TITLE)
IFE(R1=8,TITLE)
NOTE(DISK,NR)/THIRD CONDENSOR
ELSE(TITLE)
IFE(R1=9,TITLE)
NOTE(DISK,NR)/PLF
ELSE(TITLE)
IFE(R1=10,TITLE) 
NOTE(DISK,NR)/PNI
ENDIF(TITLE) 
.*  ADVANCE TO ID RECORD.
SKIPR(T,3) 
.*  COPY ID RECORD.
COPYBR(T,DISK) 
.*  ADD AN EOL.
NOTE(DISK,NR)/ 
.*  ADVANCE TO NEXT FILE.
SKIPF(T,1) 
NOTE(DISK,NR)/ 
ENDIF(EMPTY) 
.* 
SET(R1=R1+1) 
ENDW(LOOP) 
.* 
NOTE(DISK,NR)/ 
NOTE(DISK,NR)/EM DUMP FILE 
IFE(FILE(T,EOI),NOEM)
NOTE(DISK,NR)/ NOT ON TAPE.
ELSE(NOEM) 
COPYBR(T,DISK) 
ENDIF(NOEM)
REWIND(DISK) 
PACK(DISK) 
COPYSBF(DISK,OUTPUT,,NA) 
~
.PROC,DUMPPRT,F,NOCM=1/0,TID=,VSN=PLATEM.
.* 
.*        DUMPPRT PRINTS ALL INFORMATION FOR A JOB FROM
.*        A DUMP TAPE. 
.* 
.*        DUMPPRT(F,NOCM,TID,VSN)
.* 
.*        *F* IS ONE OF THE FOLLOWING STRINGS';
.*          MASTOR 
.*          MASTORN
.*          PLATO (OR EXEC0) 
.*          EXEC1
.*          EXEC2
.*          FRAMAT 
.*          FORMAT 
.*          CONDEN (OR COND0)
.*          COND1
.*          COND2
.*          PLF
.*          PNI
.* 
.*        PRESENCE OF *NOCM* DISABLES PRINT OF JOBS CM.
.* 
.*        *TID* IS A STRING USED TO IDENTIFY THE TAPE
.*        FOR THE OPERATOR (IE, E-12). 
.* 
.*        *VSN* IS THE VSN OF THE DUMP TAPE (IF NEEDED). 
.* 
.*        IF FILE ',TAPE', IS ASSIGNED AT THE BEGINNING OF 
.*        THIS PROCEDURE, NO TAPE REQUEST IS MADE.  FILE 
.*        ',TAPE', IS RETURNED BY THIS PROCEDURE.
.* 
IFE(.NOT.(FILE(TAPE,AS)),GETT) 
WAIT.  MOUNT TAPE TID
LABEL(TAPE,#F=I,#VSN=VSN,PO=FR)
ENDIF(GETT)
REWIND(TAPE) 
.* 
IFE($F$.EQ.$MASTOR$.OR.$F$.EQ.$MASTORN$,S1)
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$PLATO$.OR.$F$.EQ.$EXEC0$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$EXEC1$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$EXEC2$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$FRAMAT$,S1)
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$FORMAT$,S1)
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$CONDEN$.OR.$F$.EQ.$COND0$,S1)
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$COND1$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$COND2$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$PLF$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
SKIPF(TAPE,1)
IFE($F$.EQ.$PNI$,S1) 
SKIP(S1) 
.* 
ELSE(S1) 
$REVERT,ABORT. ILLEGAL DUMP TYPE 
ENDIF(S1)
.* 
COPYBF(TAPE,DISK)
REWIND(DISK) 
COPYBR(DISK,DFLIST)
IFE(FILE(DISK,EOF),ERR)
$REVERT,ABORT. EMPTY DUMP FILE 
ENDIF(ERR) 
COPYBR(DISK,LDMAP) 
COPYBR(DISK,EFR) 
COPYBR(DISK,OUTPUT)
IFE(NOCM=1,S2) 
COPYBF(DISK,CM)
ENDIF(S2)
.* 
UNLOAD(TAPE,DISK)
REWIND(*,OUTPUT) 
IFE(NOCM=1,S3) 
MEMPRT(CM,0,777777)
ENDIF(S3)
COPYBR(EFR,OUTPUT) 
COPYBR(LDMAP,OUTPUT) 
COPYBR(DFLIST,OUTPUT)
~
.PROC,EMPRT,FWA,LWA,TID=,VSN=PLATEM. 
.* 
.*        *EMPRT* PRINTS REQUESTED PARTS OF AN EM DUMP 
.*        FROM A DUMP TAPE.
.* 
.*        EMPRT(FWA,LWA,TID,VSN) 
.* 
.*        *FWA* IS THE FIRST WORD OF THE EM DUMP.
.* 
.*        *LWA* IS THE LAST WORD + 1 OF THE EM DUMP. 
.* 
.*        *TID* IS A STRING USED TO IDENTIFY THE TAPE
.*        FOR THE OPERATOR (IE, E-12). 
.* 
.*        *VSN* IS THE VSN OF THE DUMP TAPE (IF NEEDED). 
.* 
.*        IF FILE ',TAPE', IS ASSIGNED AT THE BEGINNING OF 
.*        THIS PROCEDURE, NO TAPE REQUEST IS MADE.  FILE 
.*        ',TAPE', IS RETURNED BY THIS PROCEDURE.
.* 
IFE(.NOT.(FILE(TAPE,AS)),GETT) 
WAIT.  MOUNT TAPE TID
LABEL(TAPE,F=I,#VSN=VSN,PO=FR) 
ENDIF(GETT)
REWIND(TAPE) 
.* 
SKIPEI(TAPE) 
SKIPFB(TAPE,1) 
COPYBF(TAPE,ECFILE)
UNLOAD(TAPE) 
MEMPRT(ECFILE,FWA,LWA) 
$REVERT. 
~
.PROC,MFTLOAD,MF=CUT,PN=,R=,VSN=,D=PE,LIST=OUTPUT,FAMILY=. 
.* 
.* 
.*      LOAD MASTER FILE TAPE. 
.*        IF *MF* IS ALREADY ATTACHED, USE THAT FILE 
.*        AND DO NOT RESET USER INDEX OR PACKNAM.
.* 
.* 
.*  PARAMETERS --
.*        MF     = MASTER FILE NAME. 
.*        PN     = PACK NAME.
.*        R      = DEVICE TYPE FOR *PN*. 
.*        VSN    = TAPE VSN. 
.*        D      = TAPE DENSITY. 
.*        LIST   = OUTPUT FILE NAME. 
.*        FAMILY = FAMILY NAME.
.* 
.*  DEFAULTS --
.*        MF     = *CUT*.
.*        PN     = NULL. 
.*        R      = NULL. 
.*        VSN    = MF. 
.*        D      = PE (1600 BPI -- ALL SITES HAVE THIS). 
.*        LIST   = *OUTPUT*. 
.*        FAMILY = NULL. 
.* 
.* 
IFE(.NOT.(FILE(MF,AS)),GETMF)
.* 
SETPUN.
PACKNAM(PN)
.* 
IFE($FAMILY$ .NE. $$, FAMLY) 
#FAMILY(FAMILY)
ENDIF(FAMLY) 
.* 
IFE($R$.EQ.$$,RESRC) 
RESOURC(D=1) 
ELSE(RESRC)
RESOURC(D=1,R=1) 
ENDIF(RESRC) 
.* 
* DEFINE FILE *MF*.
UNLOAD,MF. 
IFE($R$.EQ.$$,FILE)
PURGE(MF/NA) 
DEFINE(MF) 
ELSE(FILE) 
PURGE(MF/#R=R,NA)
DEFINE(MF/#R=R)
ENDIF(FILE)
.* 
ELSE(GETMF)
.* 
RESOURC(D=1) 
.* 
ENDIF(GETMF) 
.* 
* OBTAIN THE TAPE. 
IFE($VSN$.EQ.$$,TAPE)
LABEL(T,#D=D,F=I,#VSN=MF)
ELSE(TAPE) 
LABEL(T,#D=D,F=I,#VSN=VSN) 
ENDIF(TAPE)
.* 
* COPY TAPE TO DISK. 
COPYBF(T,MF) 
REWIND(T,MF) 
VERIFY(T,MF,A,N=1) 
.* 
* MAKE SURE PLATO NAME = NOS NAME. 
MFALTER(#MF=MF,N=MF) 
.* 
* PRINT MF 
IFE($LIST$.NE.$0$,ROUTOUT) 
REWIND(MF) 
MFPRINT(#MF=MF,L=LIST) 
.* 
DAYFILE(L=LIST)
ENDIF(ROUTOUT) 
.* 
REVERT.
.* 
EXIT.
WAIT.  MASTER FILE LOAD FAILED.
REVERT(ABORT)
~
.PROC,MFTCOPY,MF,PN=$$,R=$$,VSN=$$,L=$$,D=PE,LIST=OUTPUT.
.* 
.*      COPY MASTER FILE TO TAPE.
.*        IF *MF* IS ALREADY ATTACHED, USE THAT FILE 
.*        AND DO NOT RESET USER INDEX OR PACKNAM.
.* 
.*        ENTRY  MF = MASTER FILE NAME 
.*               PN = NOS PACK NAME (DEFAULT = SYSTEM PACK)
.*               R = DISK DEVICE TYPE (DEFAULT = SYSTEM DEFAULT) 
.*               VSN = TAPE VSN (DEFAULT IS TO USE MF NAME)
.*               L = TAPE LABEL (NO DEFAULT) 
.*               D = DESIRED TAPE DENSITY (DEFAULT = PE) 
.*               LIST = OUTPUT FILE NAME (DEFAULT = OUTPUT)
.* 
UNLOAD(ZZZZZMF)
IFE(.NOT.(FILE(MF,AS)),GETMF)
.* 
IFE($R$.NE.$$,RESRC) 
RESOURC(D=1,R=1) 
ELSE(RESRC)
RESOURC(D=1) 
ENDIF(RESRC) 
.* 
.*         ATTACH DESIRED MASTER FILE
.* 
SETPUN.
REQPACK(PN)
.* 
IFE($R$.NE.$$,ATTCH) 
ATTACH(ZZZZZMF=MF/#R=R)
ELSE(ATTCH)
ATTACH(ZZZZZMF=MF) 
ENDIF(ATTCH) 
.* 
ELSE(GETMF)
.* 
RESOURC(D=1) 
RENAME(ZZZZZMF=MF) 
.* 
ENDIF(GETMF) 
.* 
.*        OBTAIN THE TAPE.  IF NO VSN PARAMETER PASSED, THEN 
.*        SET VSN = MF NAME. 
.* 
IFE($VSN$.EQ.$$,TAPE)
BLANK(#VSN=MF,#D=D)
WAIT(2)
.*        WAIT FOR MAGNET/RESEX TO FIGURE IT OUT.
LABEL(T,#D=D,F=I,#VSN=MF,W,#L=L,PO=FW) 
ELSE(TAPE) 
BLANK(#VSN=VSN,#D=D) 
WAIT(2)
.*        WAIT FOR MAGNET/RESEX TO FIGURE IT OUT.
LABEL(T,#D=D,F=I,#VSN=VSN,W,#L=L,PO=FW)
ENDIF(TAPE)
.* 
.*        COPY DISK COPY TO TAPE.  INCLUDE A 2ND *EOF*,
.*        AS REQUIRED BY SMD.
.* 
COPYBF(ZZZZZMF,T)
WRITEF(T)
REWIND(ZZZZZMF,T)
VERIFY(ZZZZZMF,T,A,N=1)
UNLOAD(T)
.* 
.*        GET LISTING
.* 
IFE($LIST$.NE.$0$,ROUTOUT) 
MFPRINT(#MF=ZZZZZMF,#L=LIST) 
UNLOAD(ZZZZZMF)
DAYFILE(#L=LIST) 
ELSE(ROUTOUT)
RENAME(MF=ZZZZZMF) 
ENDIF(ROUTOUT) 
.* 
REVERT.
EXIT.
WAIT.  TAPE COPY FAILED. 
REVERT(ABORT)
~
.PROC,MFPACK,MF=,N=,SP=,PT=GENERAL,PN=,R=0,NPN=$*SAME*$,NR=0.
.* 
.* 
.*      PACK MASTER FILE.
.*        IF *MF* IS ALREADY ATTACHED, USE THAT FILE 
.*        AND DO NOT RESET USER INDEX OR PACKNAM.
.* 
.* 
.*      PARAMETERS --
.*              MF      = OLD MASTER FILE NAME.
.*              N       = NEW MASTER FILE NAME (DEFAULT =
.*                        OLD MASTER FILE NAME). 
.*              SP      = NEW MASTER FILE LENGTH.
.*              PT      = NEW MASTER FILE TYPE (DF=GENERAL). 
.*              PN      = DISK PACK WHERE OLD MF RESIDES 
.*                        (DEFAULT = SYSTEM PACK). 
.*              R       = PACK TYPE FOR *PN* (DF = NONE).
.*              NPN     = DISK PACK WHERE NEW MF RESIDES 
.*                        (DEFAULT = SYSTEM PACK, IF NEW MF
.*                        NAME IS DIFFERENT THAN *MF*).
.*              NR      = PACK TYPE FOR *NPN* (DF = NONE, IF 
.*                        NEW MF NAME IS DIFFERENT THAN
.*                        *MF*). 
.* 
.* 
IFE(.NOT.(FILE(MF,AS)),GETMF)
SETPUN.
.* 
IFE($R$.NE.$0$ .AND. $R$.NE.$$, RESRC1)
RESOURC(R=1) 
ENDIF(RESRC1)
.* 
.*        ATTACH THE OLD MASTER FILE.
.* 
REQPACK(PN)
ATTACH(MF/#R=R)
ENDIF(GETMF) 
.* 
.*        GENERATE THE INTERMEDIATE FILE.
.* 
UNLOAD(LIST,SOURCE)
MFLIST(#MF=MF,L=LIST)
REWIND(LIST) 
PFOUT(#MF=MF,I=LIST) 
RETURN(MF) 
.* 
.*        CREATE THE NEW MASTER FILE (EITHER *N* OR *MF*). 
.*        ONLY CHANGE NOS PACKS IF NEW MF NAME .NE. OLD MF 
.*        NAME.
.* 
IFE($NPN$.NE.$*SAME*$,NEWPACK) 
IFE($NR$.NE.$0$ .AND. $NR$.NE.$$,NEWP1)
RESOURC(NR=1)
ENDIF(NEWP1) 
REQPACK(NPN) 
ELSE(NEWPACK)
IFE($N$.NE.$$,NEWP2) 
PACKNAM. 
ENDIF(NEWP2) 
ENDIF(NEWPACK) 
.* 
.*        CALL LOCAL PROCEDURE *ZZZZMFC* TO CREATE THE NEW 
.*        MASTER FILE WITH THE APPROPRIATE CHARACTERISTICS.
.* 
IFE($N$.EQ.$$ .AND. $NPN$.EQ.$*SAME*$, MFC)
BEGIN(,ZZZZMFC,MFNAME=MF,PTYPE=PT,SPACE=SP,DTYPE=R)
ELSE(MFC)
IFE($N$.EQ.$$ .AND. $NPN$.NE.$*SAME*$, MFC)
BEGIN(,ZZZZMFC,MFNAME=MF,PTYPE=PT,SPACE=SP,DTYPE=NR) 
ELSE(MFC)
IFE($N$.NE.$$ .AND. $NPN$.EQ.$*SAME*$, MFC)
BEGIN(,ZZZZMFC,MFNAME=N,PTYPE=PT,SPACE=SP,DTYPE=0) 
ELSE(MFC)
.*  $N$.NE.$$ .AND. $NPN$.NE.$*SAME*$. 
BEGIN(,ZZZZMFC,MFNAME=N,PTYPE=PT,SPACE=SP,DTYPE=NR)
ENDIF(MFC) 
.* 
REWIND(SOURCE) 
IFE($N$.EQ.$$,NEW4)
PFIN(#MF=MF) 
MFPRINT(#MF=MF)
.* 
ELSE(NEW4) 
PFIN(#MF=N)
MFPRINT(#MF=N) 
ENDIF(NEW4)
.* 
UNLOAD(*,OUTPUT) 
.* 
REVERT.
EXIT.
REVERT,ABORT.  MFPACK FAILED.
.* 
.* 
.DATA,ZZZZMFC. 
~
.PROC,ZZZZMFC,MFNAME,PTYPE,SPACE=,DTYPE. 
.* 
.*        PROCEDURE TO CREATE A MASTER FILE *MFNAME* OF TYPE 
.*        *PTYPE*, (OPTIONAL) LENGTH *SPACE*, AND DEVICE 
.*        TYPE *DTYPE*.  ASSUMES PROPER PACK NAME AND RE-
.*        SOURCE COUNT ALREADY SET.
.* 
UNLOAD(MFNAME) 
PURGE(MFNAME/#R=DTYPE,NA)
.* 
IFE($SPACE$.EQ.$$,DFLT)
MFCREAT(#MF=MFNAME,#PT=PTYPE,#DT=DTYPE)
ELSE(DFLT) 
MFCREAT(#MF=MFNAME,#PT=PTYPE,#DT=DTYPE,#SP=SPACE)
ENDIF(DFLT)
.* 
REVERT.
EXIT.
REVERT,ABORT.  MFC FAILED. 
~
.PROC,BKSTART. 
SETPUN.
PACKNAM,.
PURGE,COMBUF/NA. 
DEFINE,COMBUF=COMBUF.
*----
REVERT.
~
.PROC,RECOVAL. 
.* 
.*        RECOVER ALL OR SOME MASTER FILES.
.* 
.*        PLATO MUST BE DOWN AS ALL FILES ARE ATTACHED IN
.*        WRITE MODE.
.* 
*----
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
MFNX(M=W)
RESOURC(GE=1)
COPYPF.
REVERT.
~
.PROC,RECOVMF,MF=,PN=0,R=0,D=PE,N=.
.* 
.*        RECOVER ONE MASTER FILE. 
.* 
.*        IF PLATO IS NOT DOWN, THE FILE MUST BE UNLOADED
.*        FROM PLATO VIA *LDR*.
.* 
.*        PARAMETERS --
.* 
.*               MF = MASTER FILE TO BE RECOVERED. 
.*               PN = PACK ON WHICH *MF* RESIDES.  DEFAULT 
.*                    IS DEFAULT FAMILY (SYSTEM PACK). 
.*               R  = DEVICE TYPE OF *PN*.  DEFAULT IS *0* 
.*                    (NOT SYSTEM DEFAULT DEVICE TYPE).
.*               D  = DUMP TAPE DENSITY.  DEFAULT IS *PE*. 
.*               N  = DESIRED NEW MASTER FILE NAME.  DEFAULT 
.*                    IS ORIGINAL MASTER FILE NAME.
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*  IF NO REMOVABLE PACK IS SPECIFIED, 
.*  THEN JUST -RESOURC- FOR A TAPE; ELSE 
.*  INCLUDE THE REMOVABLE PACK.
.* 
SETPUN.
IFE($PN$.EQ.$0$,REMOVE)
RESOURC(D=1) 
ELSE(REMOVE) 
RESOURC(R=1,D=1) 
ENDIF(REMOVE)
.* 
.*  DEPENDING ON WHETHER OR NOT A NEW
.*  MASTER FILE NAME IS SPECIFIED, EITHER
.*  ATTACH THE EXISTING OR THE NEW FILE. 
.* 
IFE($N$.EQ.$$,MFN1)
ATTACH(MF/M=W,#PN=PN,#R=R,NA)
ELSE(MFN1) 
ATTACH(MF=N/M=W,#PN=PN,#R=R,NA)
ENDIF(MFN1)
.* 
.*  IF THE FILE DOES NOT EXIST, GIVE 
.*  THE USER THE OPTION TO DEFINE IT.
.* 
.*  DEPENDING ON WHETHER OR NOT A NEW
.*  FILE NAME IS TO BE USED, DEFINE IT 
.*  WITH EITHER THE ORIGINAL OR NEW FILE 
.*  NAME.
.* 
IFE(.NOT.FILE(MF,AS),DEFINE) 
$WAIT.  *GO* TO DEFINE FILE. 
IFE($N$.EQ.$$,MFN2)
DEFINE(MF/M=RM,CT=PU,#PN=PN,#R=R)
ELSE(MFN2) 
DEFINE(MF=N/M=RM,CT=PU,#PN=PN,#R=R)
ENDIF(MFN2)
ENDIF(DEFINE)
.* 
.*  EXECUTE THE -COPYPF- CARD TO RECOVER 
.*  THE SPECIFIED MASTER FILE.  IF NOT ON
.*  A REMOVABLE PACK, OMIT THE PACK NAME 
.*  ARGUMENT.
.* 
IFE($PN$.EQ.$0$,NOPACK)
COPYPF(Z)#MF=MF. 
ELSE(NOPACK) 
COPYPF(Z)#MF=MF,#PN=PN.
ENDIF(NOPACK)
.* 
.*  IF THERE WAS AN ALTERNATE NAME 
.*  SPECIFIED, USE -MFALTER- TO SET
.*  THE INTERNAL MF NAME TO THAT.
.* 
IFE($N$.EQ.$$,MFN3)
MFALTER(#MF=MF,#N=N) 
ELSE(MFN3) 
.* 
REVERT.  RECOVMF 
EXIT.
***********************************
***********************************
*                                 *
*             ERRORS              *
*                                 *
***********************************
***********************************
REVERT,ABORT.  RECOVMF 
~
.PROC,BACKDMP,VSN=$$,D=GE. 
.* 
.*        DUMP(BACKUP) PLATO MASTER FILES
.* 
.*        VSN = DUMP TAPE VSN
.* 
.*        D   = DUMP TAPE DENSITY
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
.*        ATTACH ALL MASTER FILES, THEN DUMP THEM
.* 
MFNX(M=R)
RESOURC(D=1) 
IFE,($VSN$=$$),DUMP. 
MFDX.
ELSE(DUMP) 
MFDX(#VSN=VSN) 
ENDIF(DUMP)
.* 
.*        FINISH DUMP(BACKUP) PROCEDURE
.* 
.*        MERGES OLD DUMP DIRECTORY AND NEW COMMUNICATIONS 
.*        BUFFER.
.* 
SETPUN.
ATTACH,COMBUF. 
REWIND(COMBUF) 
CATALOG(COMBUF)
FILE(TAPE3,BT=C,RT=F,FL=40)
FILE(TAPE4,BT=C,RT=F,FL=40)
BACKONE. 
SORT5.DIR=SORT5D 
BACKTWO. 
UNLOAD,COMBUF. 
SETPUN.
PURGE,COMBUF/NA. 
DEFINE,COMBUF=COMBUF.
BACKLIB. 
*----
REVERT.
*----
EXIT.
SETPUN.
PACKNAM,.
ATTACH,COMBUF. 
REWIND(COMBUF) 
CATALOG(COMBUF)
$WAIT.  PLATO DUMPS FAILED 
REVERT.
.DATA,SORT5D.
SORT,FROM=TAPE3,TO=TAPE4.. 
KEY=((1,10,INTEGER),(11,10,INTEGER),(21,10,INTEGER)) 
~
.PROC,PAFTERM*I
,ALFNS    [ACCOUNT LOG FILE NAME SUFFIX] 
=(*S1..5(ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789))
,AFFLAG   [SAVE THE NOS ACCOUNT LOG FILE. ENTER YES OR NO] 
=(Y,N,YES=Y,NO=N,*N=Y) 
,PN       [ALTERNATE PACK NAME TO STORE *RAFMON* ON] 
=(*F,0,*N=)
,R        [ALTERNATE PACK DEVICE TYPE] 
=(DB,DC,DD,DG,DI,DJ,DK,DL,DM,DQ,DV,DW,*N=) 
.
.*        PAFTERM - PLATO ACCOUNT LOG FILE TERMINATOR
.*        THIS PLATO SYSTEM PROCEDURE IS USED TO TERMINATE 
.*        AND MANAGE YOUR NOS ACCOUNT FILE LOG FOR PRO-
.*        CESSING BY THE PLATO ROYALTY ACCOUNT FILE MESSAGE
.*        SIFTER.
.*        DSD COMMAND FORMAT'; 
.* 
.*        X.PAFTERM(ALFNS[,AFFLAG,PN,R]) 
.* 
SETTL(*) 
SETASL(*)
RFL(100000)
.IF,OT.EQ.SYO,PAFTM1.
*  EXECUTING *PAFTERM* FROM THE CONSOLE
*  BEGIN FIRST PHASE OF ACCOUNT LOG PROCESSING 
*  BY TERMINATING THE ACCOUNT LOG FILE 
BEGIN(ENDAFL,ENDAFL,ALFNS) 
SKIP,PAFTM2. 
EXIT.
***************************************
*                                     *
* ERROR--PROCEDURE *ENDAFL* FAILED    *
* EXAMINE THE OUTPUT FROM THIS JOB TO *
* DETERMINE THE CAUSE OF THE FAILURE. *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.PAFTERM FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. PROCEDURE *ENDAFL* FAILED
ENDIF,PAFTM2.
UNLOAD(ENDAFL) 
.IF,$AFFLAG$.EQ.$N$,PAFTM2.
*  PURGE THE NOS ACCOUNT LOG FILE AC_ALFNS 
PURGE(AC_ALFNS)
.ENDIF,PAFTM2. 
.IF,(($PN$.NE.$$).AND.($R$.NE.$$)),PAFTM2. 
*  SET ALTERNATE PACK TO PN/#R=R.
RESOURC(R=1) 
REQPACK(PN,#R=R) 
.ELSE,PAFTM2.
*  SET PACK TO SYSTEM DEFAULT
PACKNAM. 
.ENDIF,PAFTM2. 
ATTACH(RAFMON/M=A,WB)
SKIP,PAFTM2. 
EXIT.
***************************************
*                                     *
* ERROR--FILE *RAFMON* NOT FOUND.     *
* FILE *RAFMON* IS MISSING OR         *
* PACK NAME AND/OR PACK DEVICE TYPE   *
* NOT PROPERLY SPECIFIED.             *
*                                     *
* PLEASE CORRECT PROBLEM AND TRY      *
* AGAIN.                              *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.PAFTERM FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. FILE *RAFMON* MISSING
ENDIF,PAFTM2.
REWIND(PRAF) 
SKIPEI(RAFMON) 
COPYEI,PRAF,RAFMON.
WRITEF(OUTPUT) 
REVERT. *PAFTERM* COMPLETE 
.ELSE,PAFTM1.
***************************************
*                                     *
* *PAFTERM* NOT SUPPORTED FROM THIS   *
* ORIGIN TYPE.                        *
* *PAFTERM* IS ONLY SUPPORTED FROM    *
* THE CONSOLE AT THIS TIME.           *
* PLEASE TRY *PAFTERM* FROM THE       *
* CONSOLE.                            *
*                                     *
* *PAFTERM* WAS NOT RUN.              *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.PAFTERM WAS NOT RUN, DO *DAYFILE,JSN.*
REVERT,ABORT. PROCEDURE *PAFTERM* FAILED 
.ENDIF,PAFTM1. 
.IF,OT.EQ.SYO,PAFTM1.
.DATA,ENDAFL.
.EXPAND,OFF. 
~
.PROC,ENDAFL*I 
,P1       [ACCOUNT LOG SUFFIX] 
=(*A)
.
*  SET TO SYSTEM PACK TO DUMP ACCOUNT LOG AC_P1
PACKNAM. 
PURGE(AC_P1/NA)
DFTERM(FT=ACCOUNT,NM=P1,PO=N)
ATTACH(RAF=AC_P1)
*  STRIP PLATO ONLY MESSAGES OUT OF ACCOUNT LOG FILE 
PORAFM.
SKIP,ENDAF1. 
EXIT.
***************************************
*                                     *
* ERROR--PROGRAM *PORAFM* HAD ERRORS. *
* PLEASE CHECK THE JOB OUTPUT AND THE *
* JOB DAYFILE FOR THE CAUSE OF THE    *
* FAILURE.                            *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDAFL FAILED, DO *DAYFILE,JSN.*
REVERT,ABORT. PROGRAM *PORAFM* FAILED
ENDIF,ENDAF1.
UNLOAD(RAF)
REVERT. ENDAFL COMPLETE
.EXPAND. 
.ENDIF,PAFTM1. 
~
.PROC,ENDOFBC*I
,RID      [ROUTING IDENTIFIER(RID)FOR YOUR SYSTEM] 
=(*S1..3(ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789))
,TDEN     [TAPE DENSITY. ENTER PE OR GE] 
=(*N=PE,PE,GE) 
,DTYPE    [DATA TYPE FORMAT AS SPECIFIED BY CDC] 
=(*N=5,1,2,3,4,5,6)
,RMFLAG   [SAVE A COPY OF *RAFMON* ON DISK. ENTER YES OR NO] 
=(Y,N,YES=Y,NO=N,*N=Y) 
,BCFLAG   [SAVE A COPY OF *BCFILE* ON DISK. ENTER YES OR NO] 
=(Y,N,YES=Y,NO=N,*N=Y) 
,PN       [ALTERNATE PACK NAME TO FIND FILE *RAFMON*]
=(*F,0,*N=)
,R        [DEVICE TYPE OF ALTERNATE PACK]
=(DB,DC,DD,DG,DI,DJ,DK,DL,DM,DQ,DV,DW,*N=) 
.
.*        ENDOFBC - END OF THE BILLING CYCLE PROCESSOR 
.*        THIS PLATO SYSTEM PROCEDURE IS USED TO PROCESS THE 
.*        *RAFMON* FILE FOR THE END OF THE BILLING CYCLE.
.*        THIS PROCEDURE PRODUCES A TAPE WHICH IS SENT TO
.*        THE ADDRESS LISTED IN THE PLATO OPERATIONS GUIDE.
.*        DSD COMMAND FORMAT'; 
.* 
.*        X.ENDOFBC(RID[,TDEN,DTYPE,RMFLAG,BCFLAG,PN,R]) 
.* 
SUI(377777)
SETTL(*) 
SETASL(*)
RFL(100000)
.IF,OT.EQ.SYO,ENDBC1.
*  EXECUTING *ENDOFBC* FROM THE CONSOLE
.IF,(($PN$.NE.$$).AND.($R$.NE.$$)),ENDBC2. 
*  SET ALTERNATE PACK TO PN/#R=R.
RESOURC(R=1) 
REQPACK(PN,#R=R) 
.ELSE,ENDBC2.
*  SET PACK TO SYSTEM DEFAULT
PACKNAM. 
.ENDIF,ENDBC2. 
ATTACH(RAF=RAFMON) 
SKIP,ENDBC2. 
EXIT.
***************************************
*                                     *
* ERROR--FILE *RAFMON* NOT FOUND      *
* FILE *RAFMON* IS MISSING OR         *
* PACK NAME AND/OR PACK DEVICE TYPE   *
* NOT PROPERLY SPECIFIED.             *
*                                     *
* PLEASE CORRECT PROBLEM AND TRY      *
* AGAIN.                              *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. FILE *RAFMON* MISSING
ENDIF,ENDBC2.
*  BEGIN FIRST PHASE OF *RAFMON* PROCESSING
RAFPBC.
SKIP,ENDBC2. 
EXIT.
***************************************
*                                     *
* ERROR--PROGRAM *RAFPBC* HAD ERRORS  *
* PLEASE CHECK FILE *OUTPUT* AND THE  *
* JOB DAYFILE FOR PROBLEMS.           *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. PROGRAM *RAFPBC* FAILED
ENDIF,ENDBC2.
UNLOAD(RAF)
*  BEGIN SECOND PHASE OF *RAFMON* PROCESSING 
.IF,$BCFLAG$.EQ.$Y$,ENDBC2.
*  SAVE A COPY OF *BCFILE* ON DISK 
PURGE(BCFILE/NA) 
DEFINE(BC=BCFILE)
.ENDIF,ENDBC2. 
REWIND(RPAD) 
ASM1.
SKIP,ENDBC2. 
EXIT.
***************************************
*                                     *
* ERROR--PROGRAM *ASM1* HAD ERRORS    *
* PLEASE CHECK FILE *OUTPUT* AND THE  *
* JOB DAYFILE FOR PROBLEMS.           *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. PROGRAM *ASM1* FAILED
ENDIF,ENDBC2.
UNLOAD(RPAD) 
*  BEGIN THIRD PHASE OF *RAFMON* PROCESSING
*
*  SET UP PARAMETER FILE WITH DATA TYPE = DTYPE
NOTE(PARAM).DTYPE
PACK(PARAM)
REWIND(BC) 
ROYALTY. 
SKIP,ENDBC2. 
EXIT.
***************************************
*                                     *
* ERROR--PROGRAM *ROYALTY* HAD ERRORS *
* PLEASE CHECK FILE *OUTPUT* AND THE  *
* JOB DAYFILE FOR PROBLEMS.           *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. PROGRAM *ROYALTY* FAILED 
ENDIF,ENDBC2.
UNLOAD(PARAM,BC) 
*  BEGIN FOURTH PHASE OF *RAFMON* PROCESSING 
BEGIN(CPYTAPE,CPYTAPE,TAPE_DTYPE,RID,DATE+,TDEN) 
SKIP,ENDBC2. 
EXIT.
***************************************
*                                     *
* ERROR--PROCEDURE *CPYTAPE* FAILED.  *
* EXAMINE THE OUTPUT FROM THIS JOB TO *
* DETERMINE THE CAUSE OF THE FAILURE. *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC FAILED, DO *DAYFILE,JSN.* 
REVERT,ABORT. PROCEDURE *CPYTAPE* FAILED 
ENDIF,ENDBC2.
.IF,$RMFLAG$.EQ.$Y$,ENDBC2.
*  SAVE A COPY OF *RAFMON* ON DISK 
PURGE(ORAFMON/NA)
CHANGE(ORAFMON=RAFMON) 
.ELSE,ENDBC2.
*  PURGE OLD AND CURRENT *RAFMON* FILE 
PURGE(ORAFMON,RAFMON/NA) 
.ENDIF,ENDBC2. 
*  CREATE EMPTY *RAFMON* FILE FOR NEXT BILLING CYCLE 
DEFINE(RAFMON) 
UNLOAD(RAFMON,CPYTAPE) 
WRITEF,OUTPUT. 
REVERT. *ENDOFBC* COMPLETE 
.ELSE,ENDBC1.
***************************************
*                                     *
* *ENDOFBC* NOT SUPPORTED FROM THIS   *
* ORIGIN TYPE.                        *
* *ENDOFBC* IS ONLY SUPPORT FROM THE  *
* CONSOLE AT THIS TIME. PLEASE TRY    *
* *ENDOFBC* FROM THE CONSOLE.         *
*                                     *
* *ENDOFBC* WAS NOT RUN.              *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.ENDOFBC WAS NOT RUN, DO *DAYFILE,JSN.*
REVERT. PROCEDURE *ENDOFBC* FAILED 
.ENDIF,ENDBC1. 
.IF,OT.EQ.SYO,ENDBC1.
.DATA,CPYTAPE. 
.EXPAND,OFF. 
~
.PROC,CPYTAPE*I
,FN       [FILE NAME]
=(*F)
,RID      [ROUTING IDENTIFIER] 
=(*A)
,DAT      [CURRENT DATE] 
=(*A)
,DEN      [TAPE DENSITY] 
=(*A)
.
NOEXIT.
RESOURC(DEN=1) 
SET(R1=1)
WHILE,R1.NE.0,CPYTP1.
SET(EF=0)
WAIT. MOUNT A SCRATCH BILLING CYCLE TAPE 
BLANK(VSN=ACC_RID,D=DEN) 
LABEL(TAPE,VSN=ACC_RID,D=DEN,F=I,L=$PLATO/ACC_DAT$,PO=FW,W)
REWIND(FN) 
COPYEI,FN,TAPE,V,R.
*
* COPY THE ERROR REPORTING NOTESFILES TO TAPE
*
*PF(BIN,ZZZRNF1,Z)/SYSLN 
*PF(BIN,ZZZRNF2,Z)/SU*PFORUM 
*PF(BIN,ZZZRNF3,Z)/0PROBLEMS 
*
REWIND(ZZZRNF1,ZZZRNF2,ZZZRNF3)
SKIPEI(TAPE) 
COPYBF(ZZZRNF1,TAPE) 
COPYBF(ZZZRNF2,TAPE) 
COPYBF(ZZZRNF3,TAPE) 
*
UNLOAD(TAPE) 
RETURN(ZZZNRF1,ZZZRNF2,ZZZRNF3)
IF,EF.EQ.0,CHKEF.
SET(R1=0)
ELSE,CHKEF.
***************************************
*                                     *
* ERROR--TAPE MAY BE BAD.             *
* PLEASE MOUNT A NEW TAPE TO REWRITE  *
* THE BILLING CYCLE INFORMATION.      *
*                                     *
* ANOTHER POSSIBLE CAUSE IS THAT THE  *
* CYBIS APPLICATION IS NOT RUNNING.   *
* CYBIS NEEDS TO BE  AVAILABLE BEFORE *
* RUNNING THIS PROCEDURE.             *
*                                     *
* WHEN YOU HAVE READ THIS MESSAGE     *
*                                     *
*  ENTER'; GO,JSN.                     * 
*                                     *
***************************************
WAIT.TAPE MAY BE BAD, DO *DAYFILE,JSN.*
ENDIF,CHKEF. 
ENDW,CPYTP1. 
ONEXIT.
REVERT. CPYTAPE COMPLETE 
.EXPAND. 
.ENDIF,ENDBC1. 
~
.PROC,PCDCONV,PCFILE=,DSET=. 
IF($PCFILE$.EQ.$$ .OR. $PCFILE$.EQ.$$,NOFILE)
NOTE.
NOTE./YOU MUST SPECIFY THE NAME OF THE FILE CONTAINING 
NOTE./THE PCD3 DATABASE AND THE NAME OF A PLATO DATASET
NOTE./AS PARAMETERS TO THIS PROCEDURE. 
NOTE.
NOTE./FOR EXAMPLE - PCDCONV,MYFILE,MYDSET. 
EXIT.
ENDIF(NOFILE)
IF(FILE(PCFILE,.NOT.AS),NOTLOC.
NOTE.
NOTE./PCFILE IS NOT A LOCAL FILE.
EXIT.
ENDIF(NOTLOC)
REWIND(PCFILE) 
NOTE./CONVERTING PCFILE
RMFCONV(PCFILE,ZZZZZZZ)
NOTE./COPYING CONVERTED FILE TO DSET 
PF(W,DAT,ZZZZZZZ,Z,1,*,RSIZE)/DSET 
DAYFILE. 
EXIT.
~
.PROC,MFDX,VSN=,SET=.
.* 
.*      MONTHLY DUMPS
.* 
IFE($VSN$=$MONTHLY$,REGULAR) 
SKIP(MONTHLY)
ENDIF(REGULAR) 
.* 
.*        DUMP MASTER FILES. 
.* 
IFE($VSN$=$$,DUMPB)
.* 
COPYMF(NA,V,MF=SYSTEM) 
COPYMF(NA,V,MF=AMAST)
COPYMF(NA,V,MF=BMAST)
COPYMF(NA,V,MF=CMAST)
COPYMF(NA,V,MF=DMAST)
COPYMF(NA,V,MF=EMAST)
COPYMF(NA,V,MF=FMAST)
COPYMF(NA,V,MF=GMAST)
COPYMF(NA,V,MF=HMAST)
COPYMF(NA,V,MF=IMAST)
COPYMF(NA,V,MF=JMAST)
COPYMF(NA,V,MF=KMAST)
COPYMF(NA,V,MF=LMAST)
COPYMF(NA,V,MF=MMAST)
COPYMF(NA,V,MF=NMAST)
COPYMF(NA,V,MF=OMAST)
COPYMF(NA,V,MF=PMAST)
COPYMF(NA,V,MF=QMAST)
ELSE(DUMPB)
.* 
COPYMF(NA,V=VSN#T01,MF=SYSTEM) 
COPYMF(NA,V=VSN#T02,MF=AMAST)
COPYMF(NA,V=VSN#T03,MF=BMAST)
COPYMF(NA,V=VSN#T04,MF=CMAST)
COPYMF(NA,V=VSN#T05,MF=DMAST)
COPYMF(NA,V=VSN#T06,MF=EMAST)
COPYMF(NA,V=VSN#T07,MF=FMAST)
COPYMF(NA,V=VSN#T08,MF=GMAST)
COPYMF(NA,V=VSN#T09,MF=HMAST)
COPYMF(NA,V=VSN#T10,MF=IMAST)
COPYMF(NA,V=VSN#T11,MF=JMAST)
COPYMF(NA,V=VSN#T12,MF=KMAST)
COPYMF(NA,V=VSN#T13,MF=LMAST)
COPYMF(NA,V=VSN#T14,MF=MMAST)
COPYMF(NA,V=VSN#T15,MF=NMAST)
COPYMF(NA,V=VSN#T16,MF=OMAST)
COPYMF(NA,V=VSN#T17,MF=PMAST)
COPYMF(NA,V=VSN#T18,MF=QMAST)
.* 
ENDIF(DUMPB) 
.* 
REVERT. MFDX COMPLETE
.* 
ENDIF(MONTHLY) 
.* 
IFE($SET$=$$,NOSET)
SKIP(BOMB) 
ENDIF(NOSET) 
.* 
COPYMF(NA,V=MTH_SET_01,MF=SYSTEM)
COPYMF(NA,V=MTH_SET_02,MF=AMAST) 
COPYMF(NA,V=MTH_SET_03,MF=BMAST) 
COPYMF(NA,V=MTH_SET_04,MF=CMAST) 
COPYMF(NA,V=MTH_SET_05,MF=DMAST) 
COPYMF(NA,V=MTH_SET_06,MF=EMAST) 
COPYMF(NA,V=MTH_SET_07,MF=FMAST) 
COPYMF(NA,V=MTH_SET_08,MF=GMAST) 
COPYMF(NA,V=MTH_SET_09,MF=HMAST) 
COPYMF(NA,V=MTH_SET_10,MF=IMAST) 
COPYMF(NA,V=MTH_SET_11,MF=JMAST) 
COPYMF(NA,V=MTH_SET_12,MF=KMAST) 
COPYMF(NA,V=MTH_SET_13,MF=LMAST) 
COPYMF(NA,V=MTH_SET_14,MF=MMAST) 
COPYMF(NA,V=MTH_SET_15,MF=NMAST) 
COPYMF(NA,V=MTH_SET_16,MF=OMAST) 
COPYMF(NA,V=MTH_SET_17,MF=PMAST) 
COPYMF(NA,V=MTH_SET_18,MF=QMAST) 
COPYMF(NA,V=MTH_SET_19,MF=DEVELOP) 
COPYMF(NA,V=MTH_SET_20,MF=UOLMISC) 
COPYMF(NA,V=MTH_SET_21,MF=UOLJSEP) 
COPYMF(NA,V=MTH_SET_22,MF=PUBA)
COPYMF(NA,V=MTH_SET_23,MF=PUBB)
COPYMF(NA,V=MTH_SET_24,MF=PUBC)
COPYMF(NA,V=MTH_SET_25,MF=PUBD)
COPYMF(NA,V=MTH_SET_26,MF=PUBE)
COPYMF(NA,V=MTH_SET_27,MF=PUBF)
COPYMF(NA,V=MTH_SET_28,MF=PUBG)
COPYMF(NA,V=MTH_SET_29,MF=PUBH)
COPYMF(NA,V=MTH_SET_30,MF=PUBI)
COPYMF(NA,V=MTH_SET_31,MF=PUBJ)
.* 
REVERT.
.* 
SKIP(NEXT1)
EXIT.
ENDIF(BOMB)
** ERRORS IN MFDX
WAIT. MFDX     CALL MIKE IT BOMBED 
REVERT,ABORT. MFDX     CALL MIKE IT BOMBED 
ENDIF(NEXT1) 
~
.PROC,SETPUN,PW=PLATOMF,FM=. 
.* 
.*      SET PLATO USER NAME. 
.* 
IFE(OT.NE.SYO,ORIGIN)
REVERT,ABORT.
ENDIF(ORIGIN)
.* 
USER(PLATOMF,PW,FM)
.* 
REVERT.
~
.PROC,SYSTEST. 
*    10/24/94
.SET,TODAY=STRD(DAYS-4724).
.SET,YESTER=STRD(DAYS-4725). 
.SET,OLDER=STRD(DAYS-4726).
.SET,OLDER2=STRD(DAYS-4728). 
*
*
SETJOB(UJN=FAATEST,DC=NO)
USER(SYSTEMX,SYSTEMX)
SETTL(*) 
SETASL(*)
RFL(100000)
*
GETLOG.
*
* DELETE PREVIOUS DAYFILE
*
PURGE,DFLOCL/NA. 
*
* CREATE NEW DAYFILE =DFLOCL=
* TERMINATE SYSTEM DAYFILE 
*
DFTERM(PO=N,FT=DAYFILE,NM=LOCL)/GO/STOP. 
ATTACH,DFLOCL/M=R. 
*
* ADD DAYFILE TO DATA BASE 
*   =DAYBSE= 
*
ATTACH,DAYBSE/M=W. 
REWIND,*.
SKIPEI,DAYBSE. 
COPYEI,DFLOCL,DAYBSE.
PACK,DAYBSE. 
REWIND,*.
RETURN,DFLOCL,DAYBSE.
*
* PROCESS ERRLOG TERMINATE 
*   COPY TO =ERRBSE= 
*
PURGE,ERLOCL/NA. 
DFTERM(PO=N,FT=ERRLOG,NM=LOCL)/GO/STOP.
ATTACH,ERLOCL/M=R. 
ATTACH,ERRBSE/M=W. 
REWIND,*.
SKIPEI,ERRBSE. 
COPYEI,ERLOCL,ERRBSE.
PACK,ERRBSE. 
REWIND,*.
RETURN,ERRBSE,ERLOCL.
*
* PROCESS MAINLOG TERMINATE
*   COPY TO =MLBSE=
*
PURGE,MLLOCL/NA. 
DFTERM(PO=N,FT=MAINLOG,NM=LOCL)/GO/STOP. 
ATTACH,MLLOCL/M=R. 
ATTACH,MLBSE/M=W.
REWIND,*.
SKIPEI,MLBSE.
COPYEI,MLLOCL,MLBSE. 
PACK,MLBSE.
REWIND,*.
RETURN,MLLOCL,MLBSE. 
*
** PROCESS CE REPORTS
NORM(F). 
COPYBF,SEF,SEF_TODAY.
REPLACE,SEF_TODAY/       NA. 
NOTE./CURRENT SEF FILE IS SEF_TODAY
REWIND,SEF_TODAY.
PURGE,SEF_YESTER/NA. 
PURGE,SEF_OLDER/NA.
PURGE,SEF_OLDER2/NA. 
RETURN,SEFHIST.
ATTACH,SEFHIST/UN=CONTC,M=W. 
SKIPR,SEFHIST,1. 
COPYEI,SEFHIST,NEWHIST.
REWIND,SEFHIST,NEWHIST.
COPYEI,NEWHIST,SEFHIST.
RETURN,NEWHIST.
REWIND,SEFHIST.
SKIPEI,SEFHIST.
COPYBR,SEF_TODAY,SEFHIST,1.
REWIND,SEFHIST.
RETURN,SEFHIST.
RETURN,SEF_TODAY.
IF,.NOT.FILE(SEFP,AS),A1.
ATTACH,SEFP/UN=CONTC.
ENDIF,A1.
SEFP,I=INDATA,L=SEFPOUT. 
REWIND,*.
REPLACE,SEFPOUT/UN=CONTC,NA. 
COPY,SEFPOUT,SEFPFAA.
*
REWIND,*.
*
** SET UP OUTFILE AND HEADDER
*
BLOCK,BIGREP,R./SYSTEM/FAA/REPORTS/DATE/TIME 
*
** PLACE CE REPORTS IN OUTFILE 
*
COPYEI,SEFPFAA,BIGREP. 
*
** TERMINATE ACCOUNT FILE
*
PURGE(ACALA/NA)
DFTERM(FT=ACCOUNT,NM=ALA,PO=N) 
ATTACH(RAF=ACALA)
REWIND,RAF.
*
** STRIP CYBIS MESSAGES OUT
*
PORAFM.
*
** MODIFIES FIRST TWO LINES OF 
** ACCOUNT FILE TO REMOVE THE
** ABSY AND ABST TAGS. THIS
** ALLOWS FOR CYBIS ACCOUNT
** FILE TERMINATION. 
*
REWIND,PRAF. 
FSE,FN=PRAF,OP=D.S L;S U NO;R W/ABSY/XXXX/;Q 
UNLOAD(RAF)
*
** PERFORM RAFMON PROCESSING 
*
ATTACH(RAFMON/M=A,WB)
REWIND(PRAF) 
SKIPEI(RAFMON) 
COPYEI,PRAF,RAFMON.
*
** TERMINATE CDC-NET LOG FILE
*
PURGE,NLLOCL/NA. 
NLTERM(OP=Z,NM=LOCL)/GO/STOP.
COMMENT. *  TRANSFER LOG FILE TO SYSTEM DOT
ATTACH,NLLOCL/NA.
REWIND,*.
*MFLINK(NLLOCL,ST=DOT,PC=*)
*USER,NETADMN,NETADMN. 
*PURGE,NLLFAA/NA.
*DEFINE,NLLFAA.
ROUTE,BIGREP,DC=PR.
RETURN,*.
EXIT.
DAYFILE,L=SEFPABT. 
REWIND,*.
REPLACE,SEFPABT. 
REVERT,ABORT...SEFPDAY PROC FAILED, CHECK SEFPABT FILE 
.DATA,INDATA.
DISSR. 
DISDR. 
DISTMR.
DISDMR.
QUIT.
~
.PROC,RUNMCP,L=1.
ROUTE,MCPDATA,DC=NO,OT=SYOT,JSN=MCP. 
.DATA,MCPDATA. 
MCP. 
SUI=377777.
ATTACH,MCPLOCK/M=W.
SETASL,*.
SETJSL,*.
SETTL,*. 
MCP2(L)
EXIT.
XPAUSE. ** RUNMCP ABORT ** SEE DAYFILE **
~
.PROC,CLOSEDN,CPFN=CPFN,CVSN=CVSN,DATE=,DENSITY=GE.
*******************************************
*
*  CLOSEDN IS A PROC USED TO GENERATE
*  THE FINAL CLOSEDN TAPE.  IT CALLS 
*  THE FILE CPFN WHICH DIRECTS THE 
*  EXECUTION OF THE CLOSEDN RUN. 
*
*  THE FOLLOWING ENTRY POINTS IN 
*  CLOSEDN ARE : 
*
*     CLOSEDN  : CALLS CPFN
*     C100PFS  : CALLS *GENPFS*, *SECOPY* AND *MODVAL,OP=R*
*     C200MRG  : MERGE FAMILIES
*     C300CLO  : TERMINATES DAYFILES 
*     C400OLD  : *AFD*, *DFD*, *ELD* 
*     C500TPE  : COPIES CLOSEBK TO TAPE
*     C600DFM  : MERGE TWO CLOSEDN TAPES 
*     C700TMS  : CALLS *GENTMS*
*
*  FOR MORE COMPLETE DOCUMENTATION SEE 
*  THE SYSTEM MAINTENANCE REFERENCE MANUAL.
*
*******************************************
$IF(OT.NE.SYO)$EXIT. 
$RFL(15000)
$SUI(377777) 
$RETURN,VST1.
$NOTE,VST1.;.PROC,VST1.;VSN(T=CVSN)
$BLOCK./ CLOSEDOWN 
$GET(OPTS=CPFN/NA) 
$IF(FILE(OPTS,LO))$SKIP,G000STRT.
* PFN (CPFN) MISSING OR UNAVAILABLE
* CLOSEDOWN NOT ABLE TO PROCESS
XPAUSE.-SEE A DISPLAY-CLOSEDN FAILURE
$EXIT. 
$EXIT. 
$ENDIF,G000STRT. EXECUTE CENTER CLOSEDN OPTIONS
$REWIND,OPTS.
$IF,$DATE$.EQ.$$,G010STRT. 
$BEGIN,,OPTS,#DATE+,DENSITY. 
$ELSE,G010STRT.
$BEGIN,,OPTS,DATE,DENSITY. 
$ENDIF,G010STRT. 
* NORMAL TERMINATION POINT OF CLOSEDN
$EXIT. 
* ERROR IN  CALLS
XPAUSE. FAILURE IN CLOSEDOWN  =CPFN= 
$EXIT. 
$EXIT. 
~
.PROC,DEVMFNX,M=R. 
.* 
.*        ATTACH PLATO MASTER FILES
.* 
SETPUN.   SET PLATO USER NAME
RESOURC(DQ=1,GE=1) 
.* 
PACKNAM(PN=DEV0,R=DQ1) 
ATTACH(BINARY/#M=M)
ATTACH(SYSTEM/#M=M)
ATTACH(DEVMAST/#M=M) 
.* 
REVERT.
~
.proc,cftpdx.
.*
.*	start cftp daemon
.*
USER(plarecv,netderf)
cftpd.
exit.
dmd.
exit.
