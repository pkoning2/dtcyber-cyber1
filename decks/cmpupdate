cmpupd(cm160000,t77770)  -*- mode: update;-*-
user,plato,plato.
attach,old=cprndpl.
update,p=old,x.
attach,cmp2/m=w.
compass,i,l,s=iptext,s=psstext,s=scptext,s=cpctext,s=cputext,b=cmp2.
~
*ident cmtext
*i f4810b.4
*         version 3.6p  03/08/22.  p. koning.
*
*
*         version 3.6p is inspired by the work of don lee at cerl,
*         the university of illinois plato group.  this version
*         implements the *cmtext* and *cst* pseudo ops, as used
*         in plato.  the implementation is new, since I did not
*         have the cerl version available.
*i cmp30.18
*
*             c              cmtext from file *cmtext*.
*             c=0            no cmtext from a file.
*             c=lfn          cmtext from file *lfn*.
*i compass.68 
*         c=0
*d psrlevel.1
version   micro  1,4,*3.6p*
*i cmp30.351
***       common text file name.
*
 cp.ctext bssz   1

**        fet/fit for common text output file.


 cp.cfet  fet    ,cmbuf,cmbufl
          bssz   cp.cfet+8-*

 rm       ifne   cp#rm,0
          ifeq   cp#rm,6,1
 cp.cfit  file   lfn=cmtext,fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cp.cfet,fwb=obu
,f,bfs=ibufl,erl=1
          ifeq   cp#rm,7,1
 cp.bfit  file   lfn=cmtext,fo=sq,bt=,rt=w,cm=no,of=n,cf=n,pd=output
          bssz   cp.bfit+16-*
 cm       equ    cp.cfit
 rm       else
 cm       equ    cp.cfet
 rm       endif

*i cmp30.365
 cmbufl   equ    "bufl"      common text buffer length
*i cmp30.1145
 lcmcsm   data   0           lcm csyms  pointer
 lcmccm   data   0           lcm ccom   pointer
 lcmcex   data   0           lcm cext   pointer
*i compass.656
 cmname   data   0           cmtext generation name
 cmbias   equ    3           bias from csyms ccom ordinal to reloc value
*i compass.1037
**        csyms - common symbols.
*         stores the symbols defined by the *cst* pseudo operation.
*         symbols come from common text.
*
*         entry = 2 words.
*
*         word 1.
*
*         bits   59-48       unused.
*         bits   47-00       symbol right-justified with zero fill.
*
*         word 2.
*
*         bits   59-30       unused.
*         bits   29-21       ccom table ordinal + 1 or 0 if absolute.
*         bits   20-00       symbol value.


 csyms    table

**        ccom - common text blocks.
*         stores the portion of the use table defined by common text.
*
*         entry = 1 word.
*
*         word 1.
*
*         bits   59-00       block name right justified with zero fill.

 ccom     table

**        cext - common external names.
*         stores the portion of the external name table 
*         defined by common text.
*
*         entry = 1 word.
*
*         word 1.
*
*         bit    59          set if weak external (=y type).
*         bits   58-00       symbol name right justified with 00 fill.

 cext     table

*d cmp30.1204
*         bits   41-40       unused.
*         bit    39          cst flag.
*d cpsa126.16
          sb3    l.cmptab-l.inter  else empty all tables except cmptab
*i cmp26.16 
          lx6    39-32
          bx2    x2+x6       mask for cst, sst, and xtext
*i cmp30.2320
          recall cm
*i cps064.197
          rj     lct         load common text
*i cps064.277
 lcf      space  4
**        lcf - load common text from a file.
*         exit   (x0) = 0 if text loaded.


 lcf      ps                 return exit

 rm       ifeq   cp#rm,0

          sa1    cp.ctext    get file name
          sx7    3
          bx7    x1+x7
          sa7    cml         store file name in fet
          rewind cml
          rj     mtd         move tables down to get room
          sa1    o.memory
          sa2    o.endtab
          sx0    x1          preset failure return
          ix6    x2-x1
          sa0    x6          available memory
 lcf1     read   cml
 lcf2     readw  cml,x0,1    read 7700 table
          mi     x1,lcf      if eof
          nz     x1,lcf1     if eor
          sa2    x0
          lx2    18
          sx6    x2-770000b
          zr     x6,lcf4     if 7700 table
 lcf3     readw  cml,x0,a0   skip to eor
          zr     x1,lcf3
          eq     lcf1        try next record
 lcf4     lx2    6
          sx5    x2-1
          mi     x5,lcf3     if zero-length table
          readw  cml,x0,1    get record name
 lcf5     readw  cml,x0,1
          sx5    x5-1        skip 7700 table
          pl     x5,lcf5
          sa1    x0          check overlay header
          sa2    =50000102bs36
          bx6    x1-x2
          nz     x6,lcf3     if not a (1,2) overlay
 lcf6     readw  cml,x0+b1,a0-b1  read remainder of overlay
          sx0    b0          indicate text loaded
          nz     x1,lcf      if all of overlay read, return
          sx0    b6-b1       (b6) = address of last word transfered
          mx1    0
          rj     rfl         request flinc words more central memory
          zr     x3,lct7a    if request not completed, abort
          sa2    o.endtab    else set up to continue
          ix1    x2-x0       amount of space available
          sa0    x1+b1       add 1 word
          eq     lcf6        go get rest of text

 rm       else

          sa1    cp.ctext    get file name
          bx7    x1
          sa7    cgum        store file name in fit
          rj     mtd         move tables down to get room
          sx1    lcgum
          sx2    cgum
          sx3    cml         re-initialize fit
          rj     move
          sa1    o.memory
          sa2    o.endtab
          ix3    x2-x1       available words
          ix4    x3+x3
          lx3    3           multiply by 10
          ix4    x3+x4
          store  cml,mrl=x4  set maximum record length
          store  cml,wsa=x1  working storage address
          store  cml,dx=lcf8 end of data exit
          openm  cml,input,r open the file with rewind
          fetch  cml,rt,x2
          sb7    x2-#st#
          sx6    #eos#
 +        nz     b7,*+1      if not *s* records
          sx6    x6+#eor#
          sa6    cml-1

 lcf1     getp   cml,,10     get first word of section
          sa1    o.memory
          sa2    x1
          lx2    18
          sx6    x2-770000b
          zr     x6,lcf5     if 7700 table
 lcf2     getp   cml,,10     skip rest of record
 lcf3     fetch  cml,fp,x2
          sx0    #eoi#+#eop#
          bx3    x0*x2
          sa1    cml-1
          nz     x3,lcf4     if eoi or eof
          bx4    x1*x2
          zr     x4,lcf2     if not end of section
          eq     lcf1
 lcf4     closem g,r         close with rewind
          sx0    b1          indicate failure
          eq     lcf         return
 lcf5     lx2    6
          sx7    x2          word count
          ix0    x7+x7
          lx7    3           multiply by 10
          ix4    x0+x7
          getp   cml,,x4     skip the 7700 table
          getp   cml,,10     read 5000 table
          sa3    o.memory
          sa2    =50000102bs36
          sa1    x3
          bx6    x1-x2
          nz     x6,lcf2     if not a (1,2) overlay
          sx3    x3+b1
          sx4    10
          store  cml,dx=lcf9 set new data exit
          store  cml,wsa=x3
          fetch  cml,mrl,x2
          ix1    x2-x4
          store  cml,mrl=x1
 lcf6a    getp   cml,,x1     get remainder of record
          fetch  cml,fp,x1
          sx0    #eor#
          bx6    x0*x1
          zr     x6,lcf9+1   if not at eor, check for eop or eoi
          fetch  cml,ptl,x2
 lcf7     sx1    1s20/10+1
          bx4    x2          record length in characters
          ix3    x1*x2
          ax3    20          record length in words
          fetch  cml,wsa,x1
          ix3    x1+x3       adjust wsa for next get
          store  cml,wsa=x3
          fetch  cml,mrl,x2
          ix1    x2-x4       reduce mrl
          mi     x1,lcf10    if no more room, go get more fl
          store  cml,mrl=x1
          get    cml         read more of cmtext
          fetch  cml,rl,x2
          eq     lcf7        loop

 lcf8     ps                 data exit for skipping to end of section
          eq     lcf3        process of end of data

 lcf9     ps                 data exit for reading overlay
          sa2    cml-1
          fetch  cml,fp,x1
          sx0    #eoi#+#eop#+x2
          bx6    x0*x1
          zr     x6,lcf10    if not through
          sx0    b0          indicate text loaded
          sa6    exval
          closem g,r         close the file
          eq     lcf         return

 lcf10    mx1    0
          rj     rfl         request flinc words more central memory
          zr     x3,lct7a    if already at maxfl, abort
          fetch  cml,ptl,x2  get number of characters transfered
          sx1    1s20/10+1
          bx4    x2          length in characters
          ix3    x1*x2
          ax3    20          length in words
          fetch  cml,wsa,x1  get previous working storage area address
          ix3    x1+x3       adjust working storage area for next read
          store  cml,wsa=x3  store new wsa in fit
          sa2    o.endtab    end of table space
          ix3    x2-x3       words available
          ix4    x3+x3       multiply by 10 to get number of characters
          lx3    3
          ix1    x3+x4
          store  cml,mrl=x1  store new maximum record length in fit
          eq     lcf6a       go get rest of record

 rm       endif


**        fet/fit for common text loading from files.


 cmfet    fet    ,gbuf,gbufl,3

 rm       ifeq   cp#rm,0
 cml      equ    cmfet
 rm       else
          ifeq   cp#rm,6,1
 cml      file   fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cmfet,fwb=gbuf,bfs=gbufl,
,erl=1
          ifeq   cp#rm,7,1
 cml      file   fo=sq,bt=,rt=w,cm=no,pd=input
          bssz   cmfet+40b-*

          ifeq   cp#rm,6,1
 cdum     file   fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cmfet,fwb=gbuf,bfs=gbufl,
,erl=1
          ifeq   cp#rm,7,1
 cdum     file   fo=sq,bt=,rt=w,cm=no,pd=input
 lcdum    equ    *-cgum

 rm       endif
*i cps064.516
 lct      space  4
**        lct - load common text.
*
*         note that this function must be called *after* lst,
*         because both contribute to macro and micro definition
*         tables.  lct will move these to lcm (if any) when done.  

 lct      ps                 return exit

          ifne   overlay,0
          rj     asu         accumulate storage used
          sa2    locore
          bx6    x2          save normal fwa of managed table area
          sa6    lcta
          sx1    endz        set new fwa to use all available space
          rj     acl
          endif

          sa1    cp.ctext
          zr     x1,lct6     if no common text
 lct1     rj     lcf         load from file
          nz     x0,lct7     if not loaded
          sa3    o.memory
          sa2    x3+b1       common block name table length
          bx1    x2
          ax2    18          verify cmtext format
          sb2    x1+b1
          nz     x2,lct8     if bad cmtext
          sa4    o.endtab
          sb3    x4          find end of overlay
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          external table length
          sb2    x2+b1
          ax2    18          verify cmtext format
          nz     x2,lct8     if bad cmtext
          sa4    o.endtab
          sb3    x4          find end of overlay
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common symbol table length
          sb2    x2+b1
          ax2    18          verify cmtext format
          nz     x2,lct8     if bad cmtext
          sa4    o.endtab
          sb3    x4          find end of overlay
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common micro table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common macro definition table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common opcode table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sx6    b2          lwa+1 of overlay
          ix6    x6-x3
          sa6    l.memory
          manage ccom,x1     allocate common name table
          sa4    o.memory
          sa1    x4+b1
          bx3    x2
          zr     x1,lct1a    if length is zero
          sx2    a1+b1
          rj     move
          rj     asu         accumulate storage used
 lct1a    sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4+b1
          sx6    x3+2
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage cext,x1     allocate common externals table
          sa4    o.memory
          sa1    x4
          bx3    x2
          zr     x1,lct1b    if no external symbols
          sx2    a1+b1
          rj     move
          rj     asu         accumulate storage used
 lct1b    sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+b1
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage csyms,x1    allocate common symbol table
          sa4    o.memory
          sa1    x4
          bx3    x2
          zr     x1,lct2     if no common symbols
          sx2    a1+b1
          rj     move
          rj     asu         accumulate storage used
 lct2     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+b1
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage sysmic,x1
          sa4    o.memory    load system micros
          sa1    x4
          ix3    x2+x3
          zr     x1,lct3     if length is zero
          sx2    x4+b1
          ix3    x3-x1
          rj     move
          rj     asu         accumulate storage used
 lct3     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+b1
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage macdef,x1
          sa4    o.memory    load macro definition skeletons
          sa1    x4
          ix3    x2+x3
          zr     x1,lct4     if length is zero
          sx2    x4+b1
          ix3    x3-x1
          rj     move
          rj     asu         accumulate storage used
 lct4     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+2
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    l.memory
          bx6    x1
          zr     x6,lct6     if no system opcodes
 lct5     sa1    x7          look up opcode
          rj     tluop
          sa4    o.memory
          sa5    x4+b1       get equivalent
          bx7    x5
          ax5    57
          sx0    x5+b1
          sa3    lsysmac
 +        nz     x0,*+1      if not a macro
          ix7    x7+x3
 +        ax5    1
          zr     x5,lct5c    if not pseudo op
          mx0    -9
          bx5    x7
          ax5    36
          bx5    -x0*x5
          zr     x5,lct5c    if old type pseudo op entry
          lx5    1
          sa3    x5+pops-1   get equivalent from ops
          bx7    x3
 lct5c    nz     x6,lct5a    if opcode found in optab
          sa1    x4
          bx2    x7
          rj     entop       enter opcode table
          sa4    o.memory
          eq     lct5b
 lct5a    sa7    a2          replace equivalent
 lct5b    sa5    l.memory    reduce memory
          sx7    x4+2
          sx6    x5-2
          sa7    a4
          sa6    a5
          nz     x6,lct5     if more system opcodes

 lct6     sa3    l.macdef
          sa2    cp.afll
          bx6    x3
          sa6    lsysmac
          zr     x2,lct6f    if no lcm
          sa1    l.cext
          zr     x1,lct6aa   if no common externals
          rj     ilf         increase lcm field length
          mi     x6,lct6aa   if no room in lcm
          sa3    l.cext
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of common ext table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmcex
          sa2    o.cext
          rj     wlc         write common names to lcm
 lct6aa   sa1    l.ccom
          zr     x1,lct6a    if no common names
          rj     ilf         increase lcm field length
          mi     x6,lct6a    if no room in lcm
          sa3    l.ccom
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of common name table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmccm
          sa2    o.ccom
          rj     wlc         write common names to lcm
 lct6a    sa1    l.sysmic
          zr     x1,lct6b    if no system micros
          rj     ilf         increase lcm field length
          mi     x6,lct6b    if no room in lcm
          sa3    l.sysmic
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of sysmic table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmmic
          sa2    o.sysmic
          rj     wlc         write sysmic to lcm
 lct6b    sa1    l.csyms
          zr     x1,lct6c    if no common symbols
          rj     ilf         increase lcm field length
          mi     x6,lct6c    if no room in lcm
          sa3    l.csyms
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of csyms table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmcsm
          sa2    o.csyms
          rj     wlc         write csyms to lcm
 lct6c    sa1    l.optab
          rj     ilf         increase lcm field length
          mi     x6,lct6d    if no room in lcm for opcode table
          sa3    l.optab
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of opcode table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmopc
          sa2    o.optab
          rj     wlc         write optab to lcm
 lct6d    sa1    lcmend
          bx6    x1          save origin of lcm macros
          sa6    lcmsys
          sa1    l.macdef
          zr     x1,lct6f    if no system macros
          rj     ilf         increase lcm field length
          mi     x6,lct6f    if no room in lcm
          sa3    l.macdef
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of macdef table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmmac
          sa2    o.macdef
          rj     wlc         write macdef to lcm
          sa1    lcmend
          sa2    lcmsys
          bx6    x1          save end of lcm system macros
          sa6    a2
          mx7    0           indicate no system macros in scm
          sa7    lsysmac
          sx0    b1
          lx0    37          adjust all optab entries for
          bx2    x2+x0       system macros to point to macro
          sa3    l.optab     definition text in lcm
          sa4    lcmopc
          sa1    o.optab
 +        nz     x3,*+1      if opcode table not in lcm
          ax4    30
          bx3    x4
 +        sb2    2
          sb5    57          prepare to search opcode table
          sb6    -1
          sb7    x3
          sa1    x1+b1
 lct6e    ax3    x1,b5       extract opcode type
          ix6    x1+x2
          sa1    a1+b2       fetch next entry
          sb4    x3
          sb7    b7-b2
          ne     b4,b6,*+1   if not a system macro
          sa6    a1-b2       store adjusted equivalent
          nz     b7,lct6e    loop to end of table
          sa3    lcmopc
          sa2    o.optab
          zr     x3,lct6f    if opcode table not in lcm
          bx1    x3
          ax3    30
          rj     wlc         re-write to lcm

 lct6f    bss    0
          ifne   overlay,0,2
          sa1    lcta        restore normal fwa of managed table area
          rj     acl         (if no space, goes to lct7a)

          rj     asu         accumulate storage used for pass 0
          rj     ats         accumulate total storage used
          eq     lct         return

*         error exits.

 lct7     message lctn,,r    *common text not found.*
          eq     lct9
 lct7a    message lcts,,r    *insufficient storage for common text.*
          message lctt
          abort  ,nodump
 lct8     message lctf,,r    *improper common text format.*
 lct9     sa1    cp.lib
          sa2    cp.ctext    get file name
          sx6    2rc=
          bx6    x2+x6
          lx6    -12         c=fname
          sa6    lctm+2
          message lctm,,r
          mx6    0
          sa6    l.memory
          eq     lct6

 lcta     data   0           storage for (locore)
 lctn     data   c* common text not found.*
 lcts     data   c* insufficient storage for common text.*
 lctf     data   c* improper common text format.*
 lctm     data   c*  bad common text - c=fname67*
 lctt     data   c*  assembly aborted.*
*d cps064.691,cps064.706
 lst6b    sa1    l.ssyms
          zr     x1,lst6f    if no system symbols
*d cps064.708
          mi     x6,lst6f    if no room in lcm
*d cps064.719,cps064.783
*i f4810a.275
          vfd    12/0lc,18/optc,30/cp.ctext
*i f4810a.297
 optc     data   0lcmtext
*i cp147.67
          pseudo 5,cmtext
          pseudo 5,cst
*d cpsa097.8
*         buffer space for loading system or common text.
*i cps011.69
 cmtext   space  4
***       cmtext - generate a cmtext record.
*
*
*fname    cmtext
*         generate a common text record for this program.  all symbols
*         and all program macros are written in an overlay format at
*         the end of pass1.  this record can be loaded by compass.
*         if (rname) is non-blank, the cmtext record is written
*         with to the local file of that name, otherwise the default
*         filename *cmtext* is used.


          qual   pass1
 cmtext   sa1    locsym
          sa2    badloc
          zr     x2,cmx1     if location not bad
          sx6    b1
          sa6    lerr
          sa6    eflg
 cmx1     nz     x1,cmx2     if alternate record output
          sa1    idnam
 cmx2     rj     ljust
          sa7    cmname
          eq     ctl70
          space  4
**        cmtext - generate a cmtext record.


          qual   pass2
 cmtext   sa1    locsym
          zr     x1,zlist    if no alternate name
          mx6    0
          sa6    cmname
          eq     zlist       return
*i compass.6711
 cst      space  4
***       cst - common symbol table.
*
*
*         cst    sym1,sym2,,,symn
*
*         defines common symbols from the common file as if they
*         had been defined by the routine.  (symi) denotes symbols
*         that should not be defined.
*
*         note that cst (unlike sst) is required to be in the 
*         first group.  this allows us to define the common blocks
*         from the common symbols file in one consecutive batch,
*         which simplifies the mapping from block numbers in the
*         common symbol file to block numbers in the current assembly.
*         a single bias value suffices for this.

          qual   pass1
 cst      sa1    lcmccm
          zr     x1,csta     if common names not in lcm
          ax1    30
          manage ccom,x1     allocate table in scm
          sa1    lcmccm
          rj     rlc         copy table to scm
 csta     sa1    lcmcex
          zr     x1,cstb     if common externals not in lcm
          ax1    30
          manage cext,x1     allocate table in scm
          sa1    lcmcex
          rj     rlc         copy table to scm
 cstb     sa1    l.extab     get current extab size
          nz     x1,-6       should be zero
          sa1    l.cext
          manage extab,x1    allocate space in extab
          bx1    x3
          bx3    x2
          sa2    o.cext
          rj     move
          sa1    l.usetab    get current usetab size
          sb2    x1-cmbias*4 expect it to be 12 (3 blocks)
+         eq     b2,*+1
-         sa1    -4
          sa1    l.ccom
          lx1    2
          manage usetab,x1   make room for common blocks
          sa1    l.ccom
          zr     x1,csts     if no common blocks
          sb5    x1          count of common blocks to set up
          sa3    usecnt
          ix6    x1+x3
          sa6    a3          update count of used blocks
          sa6    ui+2        here also
          sa1    lword       set position counter
          sb7    x2+3*4
          sa3    o.ccom
          sa3    x3
          bx6    x1
          lx6    24
          sx7    b0
 cstc     bx7    x3
          sa7    b7          set name
          sx7    b1
          sa6    a7+b1       set position
          sa7    a6+b1       set common flag
          sx7    b0
          sa7    a7+b1       clear max org
          sa3    a3+b1       get next common name
          sb7    b7+4
          sb5    b5-b1
          gt     b5,cstc
 csts     sa1    lcmcsm
          zr     x1,cst0     if common symbols not in lcm
          ax1    30
          manage csyms,x1    allocate table in scm
          sa1    lcmcsm
          rj     rlc         copy table to scm
 cst0     sx6    b0
          sa1    qval
          sa6    p1temp
          sa6    a6+b1       p1tempa
*         p1temp  = number of arguments (symbols to ignore).
*         p1tempa = csyms entry offset.
*         qval+1  = saved qualifier.
          bx7    x1
          sa6    a1          set blank qualifier
          sa7    a1+b1
 cst1     sa1    char
          sb7    x1-1r
          zr     b7,cst7     if end of list
          rj     sclist      fetch next item
          zr     x6,cst1     ignore empty field
          sa1    p1temp
          sa6    x1+relvec   store symbol name
          sx7    x1+b1
          sa7    a1
          eq     cst1        loop
 cst3     sa2    o.csyms
          ix1    x1+x2
          sa1    x1          next common symbol
          sa2    p1temp
          sa6    a2+b1
 cst4     zr     x2,cst5     if end of ignore table
          sa4    x2+relvec-1
          sx2    x2-1
          bx6    x1-x4
          nz     x6,cst4     if not ignored
          eq     cst7
 cst5     sa2    a1+b1
          bx4    x2
          lx4    59-31
          bx3    x2
          ax3    21
          pl     x4,cst5a    if not external
          sx4    x3-1s10     set external number
          sx3    b0
          eq     cst5b
          
 cst5a    sx4    b0
          zr     x3,cst5b    if absolute
          sx3    x3+cmbias
 cst5b    sx5    1s6         set cst bit
          rj     ydefsym
 cst7     sa1    p1tempa
          sa2    l.csyms
          sx6    x1+2
          ix2    x1-x2
          nz     x2,cst3     loop to end of common symbol table
          rj     asu         accumulate storage used
          sa2    lcmcsm
          sa3    qval+1      restore qualifier
          bx7    x3
          sa7    a3-b1
          zr     x2,ctl300   if common symbols not in lcm
          mx6    0
          sa6    a6          clear scm table
          eq     ctl300      return
          space  4
**        cst - common symbol table.


          qual   pass2
 cst      equ    zlist
*i compass.7490
          rj     gcm         generate common macro text
*i cmp30.2746
          sa7    l.csyms     clear common text related tables
          sa7    l.ccom
          sa7    l.cext
*i compass.12655
 gcm      space  4
**        gcm - generate common macro text.
*
*         a common text is like a system text except that there
*         is more stuff in it.  specifically, it includes the
*         following classes of symbols --
*         - absolute symbols
*         - symbols from xtext
*         - common symbols
*         - external symbols
*
*         the following classes are excluded --
*         - symbols from system text
*         - symbols from common text
*         - qualified symbols
*         - invented symbols (8 chars starting with '?)
*         - relocatable symbols (i.e., block is not a common block)
*
*         because common symbols are included in the common
*         text, the names of common blocks are also included as
*         the first table in the common text overlay record.
*         similarly, the external symbols table is also included
*         in the common text, as the second table.
*         the four tables after that are essentially the same as
*         in an stext, other than that the symbol entries can
*         have the external or common flags and relocation number
*         fields set.
*
*         note that the location field of the cmtext pseudo specifies
*         the common text output file name, not the overlay name
*         as in the stext pseudo.

 gcm      ps                 return exit
          sa1    cmname
          zr     x1,gcm      if no cmtext generation
          sx6    3
          bx6    x6+x1
          sa6    cp.cfet     set file name in fet

 rm       ifne   cp#rm,0
          env    (4,5,7,8),x
          skip
 x        else
          fetch  cm,oc,x2
          sx6    x2-#yes#
          zr     x6,gcm0aa   if file is open
          openm  cm,output,n
          sa1    cmname
 gcm0aa   bss    0
 x        endif
 rm       endif

          sa2    ercnt
          nz     x2,gcm15    if errors
          sa3    prfx+6
          mx0    30
          bx6    x1          deck name
          sa4    =1ht
          bx3    x0*x3
          lx7    x4
          bx4    -x0*x4
          sa6    dpba+1
          sa7    a3+b1       deck type = t
          bx6    x3+x4
          sa6    a3          target, valid, *f = blanks
          sb4    prfxc
          sb5    prfxc+7
          mx6    0
 +        sa6    b4          clear prfx comment area
          sb4    b4+b1
          lt     b4,b5,*
          sa4    l.segtab    find comment text in idtab
          sa3    o.idtab
          sb7    x3
          mx0    -12
          sx5    x4-5
          sa2    l.idtab
          mi     x5,*+2      if only one segment
 +        sa4    o.segtab
          sa2    x4+5
 +        sb4    prfxc
          sb6    x3+b1
          sb7    b7+x2
 +        sa1    b6          find end of compressed ident statement
          bx6    -x0*x1
          sb6    b6+b1
          nz     x6,*-1
 +        ge     b6,b7,gcm0  if end of comment text
          sa1    b6
          sb6    b6+b1
          bx6    x1
          sa6    b4
          sb4    b4+b1
          lt     b4,b5,*-2   if prfx table not full
 gcm0     sa1    =50000102bs36
          bx6    x1
          sa6    ovlhdr

          ifeq   cp#rm,0,1
          writew cm,prfx,lprfx+1

          sa1    l.usetab
          ax1    1
          manage temtab,x1   temtab has common block table and usetab map
          sx6    -b1
          sa2    o.temtab
          sa6    x2
          sa1    l.usetab
          ax1    2
 gcm0a    sx1    x1-1
          sa6    a6+1
          nz     x1,gcm0a
          sa1    l.usetab
          sa2    o.temtab
          ax1    2           number of usetab entries
          sa1    o.usetab
          sa3    l.usetab
          sb2    -2
          sb3    x3
          sb4    -b1
          sb5    b0
 gcm0b    sb2    b2+4        advance to next usetab entry
          sb4    b4+1        advance mapping index
          ge     b2,b3,gcm0x if end of usetab
          sa3    x1+b2
          zr     x3,gcm0b    if not common block
          sb5    b5+b1
          sa3    a3-2        get common name
          sx7    b5
          bx6    x3
          sa7    x2+b4       set usetab map entry
          sa6    a6+b1       set name
          eq     gcm0b

 gcm0x    sx6    b5
          sa6    a6-b5       set count of common blocks
 rm       ifeq   cp#rm,0
          sa3    o.temtab
          sa2    l.usetab
          ax2    2
          ix3    x3+x2       address of common names buffer
          writew cm,x3,b5+b1
          writew cm,l.extab,b1 write external table length
          sa2    l.extab
          sa3    o.extab
          writew cm,x3,x2
 rm       else
          err                no rm support yet... if ever...
 rm       endif
          sa1    l.symtab    generate system symbol table
          manage duptab,x1+b1
          sb7    x3-1
          sa6    x2
          sb6    x2
          sa4    o.symtab
          sb4    x4+b7
          mx0    12
          sa1    =27777777777b external bit, rel/ext num, value
          sb2    b1+b1
          sa5    =1014bs30
          sb5    59-30
          sb3    -2r'?

*         transfer symbols from symtab to duptab.

 gcm1     zr     b7,gcm2     if end of symbol table
          sx7    b4-b7
          rx2    x7
          sb7    b7-b2
          zr     x2,gcm1     if no symbol
          sx7    x7+b1
          rx3    x7
          bx6    x0*x2
          nz     x6,gcm1     if qualified symbol
          bx4    x2
          ax4    36
          sx4    x4+b3
          zr     x4,gcm1     if local symbol
          bx4    x5*x3
          lx7    x3,b5
          nz     x4,gcm1     if set, common text, or systext
          pl     x7,gcm1     if not defined
          bx6    x1*x3
          lx7    30-31
          ng     x7,gcm1x    if external
          mx7    60-21
          bx4    x6
          bx6    -x7*x6
          ax4    21
          zr     x4,gcm1x    if absolute
          sa3    o.temtab
          ix3    x3+x4
          sa4    x3-1        common map entry for this block
          ng     x4,gcm1     if not common block
          lx4    21          position common block ordinal
          ix6    x6+x4
 gcm1x    bx7    x2
          sa7    a6+b1
          sa6    a7+b1
          eq     gcm1        loop
 gcm2     sx6    a6-b6
          sa6    b6

 rm       ifeq   cp#rm,0
          writew cm,b6,x6+b1
 rm       else
          sa1    l.mictab
          sx2    x6+b1       symbol table length
          ix3    x2+x2
          lx2    3           multiply by ten
          ix6    x2+x3
          sa6    t6rm1       save it
          ix2    x1+x1
          lx1    3           multiply micro table length by ten
          ix7    x1+x2
          sa7    a6+b1       save it too
          sx3    10*lprfx+10 add length of prfx + overlay header
          ix5    x6+x7
          sa1    b-1
          ix4    x5+x3
 +        zr     x1,*+1      if record type w
          sx4    0
          store  cm,rl=x4
          putp   cm,prfx,x3
          sa3    t6rm1
          sa2    o.duptab
          putp   cm,x2,x3
 rm       endif

          rj     asu         accumulate storage used
          sx6    b0
          sa6    l.duptab

*         write micro table.

          sa3    l.mictab
          sa2    o.mictab
          sa6    a3
          sx6    x3-1
          sa6    x2          store word count

          ifeq   cp#rm,0,2
          writew cm,x2,x3
          else   2
          sa3    t6rm2       get character count
          putp   cm,x2,x3

*         generate macro name table.

          sa1    l.optab     make room for table
          manage temtab,x1+b1
          rj     asu         accumulate storage used
          sa1    o.optab
          sa2    o.temtab
          sb2    b1+b1
          sb5    x1
          sb6    x1+nopct*2-2
          sb7    x2+b1
          mx0    12
 gcm3     gt     b5,b6,gcm9  if last hash chain finished
          sa1    b5          get first optab entry in chain
          sa2    b5+b1
          sb5    b5+b2       bump chain number
          bx5    x0*x1
          zr     x1,gcm3     if null chain
 gcm4     bx3    x2
          lx2    59-47
          sx4    b1
          bx7    x3          inspect opcode type
          ax3    57
          ix6    x1-x5
          bx4    x3+x4
          lx5    13
          zr     x4,gcm6a    if system or program macro
          mi     x2,gcm6     if program-defined non-macro
 gcm5     zr     x5,gcm3     if end of hash chain
          sa1    b6+x5       get next entry in chain
          sa2    a1+b1
          bx5    x0*x1
          eq     gcm4
 gcm6     sx4    b1          clear program-defined flag
          lx4    47
          eq     gcm7
 gcm6a    sx4    b1          clear program macro flag
          nz     x3,gcm5     if system macro, ignore it
          lx4    57
 gcm7     bx7    -x4*x7      store opcode entry into temtab
          sb4    a1          save address of current entry
          sa1    b5-b2       rescan chain to search for duplicates
 gcm8     sb3    a1
          eq     b3,b4,gcm8a if current entry
          bx3    x0*x1
          ix2    x1-x3       remove hash link
          lx3    13
          bx2    x6-x2
          sa1    b6+x3       get next to compare with current
          nz     x2,gcm8     if not duplicate, loop
          eq     gcm5        duplicate found, ignore current entry
 gcm8a    sa6    b7          no duplicate found, store
          sa7    b7+b1       current entry in temtab
          sb7    b7+b2
          eq     gcm5
 gcm9     sa1    o.temtab    store word count in first word
          sb6    x1
          sx6    b7-b6
          sx7    x6-1
          sa6    l.temtab    reduce table size
          sa7    x1

*         generate macro definition table.

          sx0    b1
          bx2    x7
          mx1    -18
          sb7    57
          lx0    38
          ax6    x0,b1
          bx1    x1-x6       (x1) = mask to clear lcm bit and address
 gcm10    sa3    x2+b6       search macro name table
          zr     x2,gcm14    if end of table
          ax4    x3,b7
          sx5    x4+b1
          sx2    x2-2
          bx6    x0*x3
          nz     x5,gcm10    if not a macro
          zr     x6,gcm11    if not already adjusted
          bx6    -x0*x3
          sa6    a3          clear flag bit
          eq     gcm10
 gcm11    sa4    l.duptab    check for synonyms
          bx6    x1*x3
          ix7    x6+x4       adjust text pointer
          sx5    x2
          sa7    a3
          bx7    x0+x7
 gcm12    zr     x5,gcm13    if end of table
          sa4    x5+b6
          bx6    x3-x4
          sx5    x5-2
          nz     x6,gcm12    if not synonymous
          sa7    a4          set flag bit
          eq     gcm12
 gcm13    sx6    x2          save pointers
          ax7    39
          sa6    p1temp      p1temp  = temtab index
          sa7    a6+b1       p1tempa = text word count
          bx6    -x1*x3      p1tempb = text fwa in macdef or lcm
          sa6    a7+b1
          manage duptab,x7   make room for text
          ix7    x2+x3
          sa1    p1tempa
          sa2    a1+b1
          lx2    59-37
          pl     x2,gcm13a   if in macdef
          lx2    37-59
          sx3    x1
          bx1    x2
          ix2    x7-x3
          rj     rlc         move text from lcm to duptab
          eq     gcm13b
 gcm13a   lx2    37-59
          sa3    o.macdef
          sx1    x1
          ix2    x2+x3
          ix3    x7-x1
          rj     move        move text from macdef to duptab
 gcm13b   sa1    o.temtab
          sa2    p1temp
          sx0    b1
          sb7    57
          sb6    x1
          mx1    -18
          lx0    38
          ax6    x0,b1
          bx1    x1-x6
          nz     x2,gcm10    if not end of macro name table

*         write macro tables.

 rm       ifeq   cp#rm,0

 gcm14    writew cm,l.duptab,1
          sa3    o.duptab
          sa4    l.duptab
          writew x2,x3,x4    write macro definition table
          sa3    o.temtab
          sa4    l.temtab
          writew x2,x3,x4    write macro name table

 rm       else

 gcm14    sa5    l.duptab
          sa4    l.temtab
          sx3    x5+b1       macro defs size + 1 for header word
          ix2    x3+x4
          ix7    x2+x2
          lx2    3
          sa1    b-1
          ix4    x2+x7
 +        zr     x1,*+1      if record type w
          sx4    0
          store  cm,rl=x4
          putp   cm,l.duptab,10
          sa5    l.duptab
          zr     x5,gcm14a   if no macro definitions
          ix7    x5+x5
          lx5    3
          ix3    x5+x7
          sa2    o.duptab
          putp   cm,x2,x3    dump macro definition table
 gcm14a   sa5    l.temtab
          ix7    x5+x5
          lx5    3
          ix3    x5+x7
          sa2    o.temtab
          putp   cm,x2,x3    dump macro name table

 rm       endif

 gcm15    weor   cm
          rj     asu         accumulate storage used
          sx6    b0
          sa6    l.duptab
          sa6    l.temtab
          eq     gcm         return
*i cmp1.54
 cmbuf    bss    cmbufl      common text buffer
