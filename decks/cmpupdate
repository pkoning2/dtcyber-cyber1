cmpupd(cm160000,t77770)  -*- mode: update;-*-
user,plato,plato.
attach,old=cprndpl.
update,p=old,x.
attach,cmp2/m=w.
compass,i,l,s=iptext,s=psstext,s=scptext,s=cpctext,s=cputext,b=cmp2.
~
*ident cmtext
*i f4810b.4
*         version 3.6p  03/08/22.  p. koning
*i cmp30.18
*
*             c              cmtext from file *cmtext*.
*             c=0            no cmtext from a file.
*             c=lfn          cmtext from file *lfn*.
*i compass.68 
*         c=0
*d psrlevel.1
version   micro  1,4,*3.6p*
*i cmp30.351
***       common text file name.
*
 cp.ctext bssz   1

**        fet/fit for common text output file.


 cp.cfet  fet    ,ibuf,ibufl
          bssz   cp.cfet+8-*

 rm       ifne   cp#rm,0
          ifeq   cp#rm,6,1
 cp.cfit  file   lfn=cmtext,fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cp.cfet,fwb=obu
,f,bfs=ibufl,erl=1
          ifeq   cp#rm,7,1
 cp.bfit  file   lfn=cmtext,fo=sq,bt=,rt=w,cm=no,of=n,cf=n,pd=output
          bssz   cp.bfit+16-*
 cm       equ    cp.cfit
 rm       else
 cm       equ    cp.cfet
 rm       endif

*i cmp30.1145
 lcmcsm   data   0           lcm csyms  pointer
 lcmccm   data   0           lcm ccom   pointer
*i compass.656
 cmname   data   0           cmtext generation name
 cmbias   equ    3           bias from csyms ccom ordinal to reloc value
*i cmp25.2
 cstcnt   data   0           number of common symbols defined
*i compass.1037
**        csyms - common symbols.
*         stores the symbols defined by the *cst* pseudo operation.
*         symbols come from common text.
*
*         entry = 2 words.
*
*         word 1.
*
*         bits   59-48       unused.
*         bits   47-00       symbol right-justified with zero fill.
*
*         word 2.
*
*         bits   59-30       unused.
*         bits   29-21       ccom table ordinal + 1 or 0 if absolute.
*         bits   20-00       symbol value.


 csyms    table

**        ccom - common text blocks.
*         stores the portion of the use table defined by common text.
*
*         entry = 1 word.
*
*         word 1.
*
*         bits   59-00       block name right justified with zero fill.

 ccom     table

*d cmp30.1204
*         bits   41-40       unused.
*         bit    39          cst flag.
*d compass.1097
*         bits   59-18       unused.
*         bits   17-0        ccom table index + 1 if common text common,
*                            1 if other common, 0 otherwise.
*d cpsa126.16
          sb3    l.cmptab-l.inter  else empty all tables except cmptab
*i cmp26.16 
          lx6    39-32
          bx2    x2+x6       mask for cst, sst, and xtext
*i cmp30.2320
          recall cm
*i cps064.197
          rj     lct         load common text
*i cps064.277
 lcf      space  4
**        lcf - load common text from a file.
*         exit   (x0) = 0 if text loaded.


 lcf      ps                 return exit

 rm       ifeq   cp#rm,0

          sa1    cp.ctext    get file name
          sx7    3
          bx7    x1+x7
          sa7    cml         store file name in fet
          rewind cml
          rj     mtd         move tables down to get room
          sa1    o.memory
          sa2    o.endtab
          sx0    x1          preset failure return
          ix6    x2-x1
          sa0    x6          available memory
 lcf1     read   cml
 lcf2     readw  cml,x0,1    read 7700 table
          mi     x1,lcf      if eof
          nz     x1,lcf1     if eor
          sa2    x0
          lx2    18
          sx6    x2-770000b
          zr     x6,lcf4     if 7700 table
 lcf3     readw  cml,x0,a0   skip to eor
          zr     x1,lcf3
          eq     lcf1        try next record
 lcf4     lx2    6
          sx5    x2-1
          mi     x5,lcf3     if zero-length table
          readw  cml,x0,1    get record name
 lcf5     readw  cml,x0,1
          sx5    x5-1        skip 7700 table
          pl     x5,lcf5
          sa1    x0          check overlay header
          sa2    =50000102bs36
          bx6    x1-x2
          nz     x6,lcf3     if not a (1,2) overlay
 lcf6     readw  cml,x0+b1,a0-b1  read remainder of overlay
          sx0    b0          indicate text loaded
          nz     x1,lcf      if all of overlay read, return
          sx0    b6-b1       (b6) = address of last word transfered
          mx1    0
          rj     rfl         request flinc words more central memory
          zr     x3,lct7a    if request not completed, abort
          sa2    o.endtab    else set up to continue
          ix1    x2-x0       amount of space available
          sa0    x1+b1       add 1 word
          eq     lcf6        go get rest of text

 rm       else

          sa1    cp.ctext    get file name
          bx7    x1
          sa7    cgum        store file name in fit
          rj     mtd         move tables down to get room
          sx1    lcgum
          sx2    cgum
          sx3    cml         re-initialize fit
          rj     move
          sa1    o.memory
          sa2    o.endtab
          ix3    x2-x1       available words
          ix4    x3+x3
          lx3    3           multiply by 10
          ix4    x3+x4
          store  cml,mrl=x4  set maximum record length
          store  cml,wsa=x1  working storage address
          store  cml,dx=lcf8 end of data exit
          openm  cml,input,r open the file with rewind
          fetch  cml,rt,x2
          sb7    x2-#st#
          sx6    #eos#
 +        nz     b7,*+1      if not *s* records
          sx6    x6+#eor#
          sa6    cml-1

 lcf1     getp   cml,,10     get first word of section
          sa1    o.memory
          sa2    x1
          lx2    18
          sx6    x2-770000b
          zr     x6,lcf5     if 7700 table
 lcf2     getp   cml,,10     skip rest of record
 lcf3     fetch  cml,fp,x2
          sx0    #eoi#+#eop#
          bx3    x0*x2
          sa1    cml-1
          nz     x3,lcf4     if eoi or eof
          bx4    x1*x2
          zr     x4,lcf2     if not end of section
          eq     lcf1
 lcf4     closem g,r         close with rewind
          sx0    b1          indicate failure
          eq     lcf         return
 lcf5     lx2    6
          sx7    x2          word count
          ix0    x7+x7
          lx7    3           multiply by 10
          ix4    x0+x7
          getp   cml,,x4     skip the 7700 table
          getp   cml,,10     read 5000 table
          sa3    o.memory
          sa2    =50000102bs36
          sa1    x3
          bx6    x1-x2
          nz     x6,lcf2     if not a (1,2) overlay
          sx3    x3+b1
          sx4    10
          store  cml,dx=lcf9 set new data exit
          store  cml,wsa=x3
          fetch  cml,mrl,x2
          ix1    x2-x4
          store  cml,mrl=x1
 lcf6a    getp   cml,,x1     get remainder of record
          fetch  cml,fp,x1
          sx0    #eor#
          bx6    x0*x1
          zr     x6,lcf9+1   if not at eor, check for eop or eoi
          fetch  cml,ptl,x2
 lcf7     sx1    1s20/10+1
          bx4    x2          record length in characters
          ix3    x1*x2
          ax3    20          record length in words
          fetch  cml,wsa,x1
          ix3    x1+x3       adjust wsa for next get
          store  cml,wsa=x3
          fetch  cml,mrl,x2
          ix1    x2-x4       reduce mrl
          mi     x1,lcf10    if no more room, go get more fl
          store  cml,mrl=x1
          get    cml         read more of cmtext
          fetch  cml,rl,x2
          eq     lcf7        loop

 lcf8     ps                 data exit for skipping to end of section
          eq     lcf3        process of end of data

 lcf9     ps                 data exit for reading overlay
          sa2    cml-1
          fetch  cml,fp,x1
          sx0    #eoi#+#eop#+x2
          bx6    x0*x1
          zr     x6,lcf10    if not through
          sx0    b0          indicate text loaded
          sa6    exval
          closem g,r         close the file
          eq     lcf         return

 lcf10    mx1    0
          rj     rfl         request flinc words more central memory
          zr     x3,lct7a    if already at maxfl, abort
          fetch  cml,ptl,x2  get number of characters transfered
          sx1    1s20/10+1
          bx4    x2          length in characters
          ix3    x1*x2
          ax3    20          length in words
          fetch  cml,wsa,x1  get previous working storage area address
          ix3    x1+x3       adjust working storage area for next read
          store  cml,wsa=x3  store new wsa in fit
          sa2    o.endtab    end of table space
          ix3    x2-x3       words available
          ix4    x3+x3       multiply by 10 to get number of characters
          lx3    3
          ix1    x3+x4
          store  cml,mrl=x1  store new maximum record length in fit
          eq     lcf6a       go get rest of record

 rm       endif


**        fet/fit for common text loading from files.


 cmfet    fet    ,gbuf,gbufl,3

 rm       ifeq   cp#rm,0
 cml      equ    cmfet
 rm       else
          ifeq   cp#rm,6,1
 cml      file   fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cmfet,fwb=gbuf,bfs=gbufl,
,erl=1
          ifeq   cp#rm,7,1
 cml      file   fo=sq,bt=,rt=w,cm=no,pd=input
          bssz   cmfet+40b-*

          ifeq   cp#rm,6,1
 cdum     file   fo=sq,bt=c,rt=s,cm=no,lt=ul,fet=cmfet,fwb=gbuf,bfs=gbufl,
,erl=1
          ifeq   cp#rm,7,1
 cdum     file   fo=sq,bt=,rt=w,cm=no,pd=input
 lcdum    equ    *-cgum

 rm       endif
*i cps064.516
 lct      space  4
**        lct - load common text.
*
*         note that this function must be called *after* lst,
*         because both contribute to macro and micro definition
*         tables.  lct will move these to lcm (if any) when done.  

 lct      ps                 return exit

          ifne   overlay,0
          rj     asu         accumulate storage used
          sa2    locore
          bx6    x2          save normal fwa of managed table area
          sa6    lcta
          sx1    endz        set new fwa to use all available space
          rj     acl
          endif

          sa1    cp.ctext
          zr     x1,lct6     if no common text
 lct1     rj     lcf         load from file
          nz     x0,lct7     if not loaded
          sa3    o.memory
          sa2    x3+b1       common block name table length
          bx1    x2
          ax2    18          verify cmtext format
          sb2    x1+b1
          nz     x2,lct8     if bad cmtext
          sa4    o.endtab
          sb3    x4          find end of overlay
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common symbol table length
          sb2    x2+b1
          ax2    18          verify cmtext format
          nz     x2,lct8     if bad cmtext
          sa4    o.endtab
          sb3    x4          find end of overlay
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common micro table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common macro definition table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sa2    b2          common opcode table length
          sb2    x2+b1
          sb2    a2+b2
          ge     b2,b3,lct8  if bad cmtext
          mi     b2,lct8
          sx6    b2          lwa+1 of overlay
          ix6    x6-x3
          sa6    l.memory
          manage ccom,x1     allocate common name table
          sa4    o.memory
          sa1    x4+b1
          bx3    x2
          zr     x1,lct1a    if length is zero
          sx2    a1+b1
          rj     move
          rj     asu         accumulate storage used
 lct1a    sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4+b1
          sx6    x3+2
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage csyms,x1    allocate common symbol table
          sa4    o.memory
          sa1    x4
          bx3    x2
          zr     x1,lct2     if no common symbols
          sx2    a1+b1
          rj     move
          rj     asu         accumulate storage used
 lct2     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+b1
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage sysmic,x1
          sa4    o.memory    load system micros
          sa1    x4
          ix3    x2+x3
          zr     x1,lct3     if length is zero
          sx2    x4+b1
          ix3    x3-x1
          rj     move
          rj     asu         accumulate storage used
 lct3     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+b1
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    x7
          manage macdef,x1
          sa4    o.memory    load macro definition skeletons
          sa1    x4
          ix3    x2+x3
          zr     x1,lct4     if length is zero
          sx2    x4+b1
          ix3    x3-x1
          rj     move
          rj     asu         accumulate storage used
 lct4     sa4    o.memory    reduce memory
          sa5    l.memory
          sa3    x4
          sx6    x3+2
          ix7    x4+x6
          ix6    x5-x6
          sa7    a4
          sa6    a5
          sa1    l.memory
          bx6    x1
          zr     x6,lct6     if no system opcodes
 lct5     sa1    x7          look up opcode
          rj     tluop
          sa4    o.memory
          sa5    x4+b1       get equivalent
          bx7    x5
          ax5    57
          sx0    x5+b1
          sa3    lsysmac
 +        nz     x0,*+1      if not a macro
          ix7    x7+x3
 +        ax5    1
          zr     x5,lct5c    if not pseudo op
          mx0    -9
          bx5    x7
          ax5    36
          bx5    -x0*x5
          zr     x5,lct5c    if old type pseudo op entry
          lx5    1
          sa3    x5+pops-1   get equivalent from ops
          bx7    x3
 lct5c    nz     x6,lct5a    if opcode found in optab
          sa1    x4
          bx2    x7
          rj     entop       enter opcode table
          sa4    o.memory
          eq     lct5b
 lct5a    sa7    a2          replace equivalent
 lct5b    sa5    l.memory    reduce memory
          sx7    x4+2
          sx6    x5-2
          sa7    a4
          sa6    a5
          nz     x6,lct5     if more system opcodes

 lct6     sa2    cp.afll
          zr     x2,lct6f    if no lcm
          sa1    l.ccom
          zr     x1,lct6a    if no common names
          rj     ilf         increase lcm field length
          mi     x6,lct6a    if no room in lcm
          sa3    l.ccom
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of common name table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmccm
          sa2    o.ccom
          rj     wlc         write common names to lcm
 lct6a    sa1    l.sysmic
          zr     x1,lct6b    if no system micros
          rj     ilf         increase lcm field length
          mi     x6,lct6b    if no room in lcm
          sa3    l.sysmic
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of sysmic table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmmic
          sa2    o.sysmic
          rj     wlc         write sysmic to lcm
 lct6b    sa1    l.csyms
          zr     x1,lct6c    if no common symbols
          rj     ilf         increase lcm field length
          mi     x6,lct6c    if no room in lcm
          sa3    l.csyms
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of csyms table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmcsm
          sa2    o.csyms
          rj     wlc         write csyms to lcm
 lct6c    sa1    l.optab
          rj     ilf         increase lcm field length
          mi     x6,lct6d    if no room in lcm for opcode table
          sa3    l.optab
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of opcode table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmopc
          sa2    o.optab
          rj     wlc         write optab to lcm
 lct6d    sa1    lcmend
          bx6    x1          save origin of lcm macros
          sa6    lcmsys
          sa1    l.macdef
          zr     x1,lct6f    if no system macros
          rj     ilf         increase lcm field length
          mi     x6,lct6f    if no room in lcm
          sa3    l.macdef
          mx7    0
          ix1    x6-x1
          sa7    a3          clear scm copy of macdef table
          lx3    30
          bx6    x3+x1
          lx3    30          set lcm table pointer
          sa6    lcmmac
          sa2    o.macdef
          rj     wlc         write macdef to lcm
          sa1    lcmend
          sa2    lcmsys
          bx6    x1          save end of lcm system macros
          sa6    a2
          mx7    0           indicate no system macros in scm
          sa7    lsysmac
          sx0    b1
          lx0    37          adjust all optab entries for
          bx2    x2+x0       system macros to point to macro
          sa3    l.optab     definition text in lcm
          sa4    lcmopc
          sa1    o.optab
 +        nz     x3,*+1      if opcode table not in lcm
          ax4    30
          bx3    x4
 +        sb2    2
          sb5    57          prepare to search opcode table
          sb6    -1
          sb7    x3
          sa1    x1+b1
 lct6e    ax3    x1,b5       extract opcode type
          ix6    x1+x2
          sa1    a1+b2       fetch next entry
          sb4    x3
          sb7    b7-b2
          ne     b4,b6,*+1   if not a system macro
          sa6    a1-b2       store adjusted equivalent
          nz     b7,lct6e    loop to end of table
          sa3    lcmopc
          sa2    o.optab
          zr     x3,lct6f    if opcode table not in lcm
          bx1    x3
          ax3    30
          rj     wlc         re-write to lcm

 lct6f    bss    0
          ifne   overlay,0,2
          sa1    lcta        restore normal fwa of managed table area
          rj     acl         (if no space, goes to lct7a)

          rj     asu         accumulate storage used for pass 0
          rj     ats         accumulate total storage used
          eq     lct         return

*         error exits.

 lct7     message lctn,,r    *common text not found.*
          eq     lct9
 lct7a    message lcts,,r    *insufficient storage for common text.*
          message lctt
          abort  ,nodump
 lct8     message lctf,,r    *improper common text format.*
 lct9     sa1    cp.lib
          sa2    cp.ctext    get file name
          sx6    2rc=
          bx6    x2+x6
          lx6    -12         c=fname
          sa6    lctm+2
          message lctm,,r
          mx6    0
          sa6    l.memory
          eq     lct6

 lcta     data   0           storage for (locore)
 lctn     data   c* common text not found.*
 lcts     data   c* insufficient storage for common text.*
 lctf     data   c* improper common text format.*
 lctm     data   c*  bad common text - c=fname67*
 lctt     data   c*  assembly aborted.*
*d cps064.691,cps064.706
 lst6b    sa1    l.ssyms
          zr     x1,lst6f    if no system symbols
*d cps064.708
          mi     x6,lst6f    if no room in lcm
*d cps064.719,cps064.783
*i f4810a.275
          vfd    12/0lc,18/optc,30/cp.ctext
*i f4810a.297
 optc     data   0lcmtext
*i cp147.67
          pseudo 5,cmtext
          pseudo 5,cst
*d cpsa097.8
*         buffer space for loading system or common text.
*i cps011.69
 cmtext   space  4
***       cmtext - generate a cmtext record.
*
*
*fname    cmtext
*         generate a common text record for this program.  all symbols
*         and all program macros are written in an overlay format at
*         the end of pass1.  this record can be loaded by compass.
*         if (rname) is non-blank, the cmtext record is written
*         with to the local file of that name, otherwise the default
*         filename *cmtext* is used.


          qual   pass1
 cmtext   sa1    locsym
          sa2    badloc
          zr     x2,cmx1     if location not bad
          sx6    b1
          sa6    lerr
          sa6    eflg
 cmx1     nz     x1,cmx2     if alternate record output
          sa1    idnam
 cmx2     rj     ljust
          sa7    cmname
          eq     ctl70
          space  4
**        cmtext - generate a cmtext record.


          qual   pass2
 cmtext   sa1    locsym
          zr     x1,zlist    if no alternate name
          mx6    0
          sa6    cmname
          eq     zlist       return
*i compass.6711
 cst      space  4
***       cst - common symbol table.
*
*
*         cst    sym1,sym2,,,symn
*
*         defines common symbols from the common file as if they
*         had been defined by the routine.  (symi) denotes symbols
*         that should not be defined.
*
*         note that cst (unlike sst) is required to be in the 
*         first group.  this allows us to define the common blocks
*         from the common symbols file in one consecutive batch,
*         which simplifies the mapping from block numbers in the
*         common symbol file to block numbers in the current assembly.
*         a single bias value suffices for this.

          qual   pass1
 cst      sa1    lcmccm
          zr     x1,csta     if common names not in lcm
          ax1    30
          manage ccom,x1     allocate table in scm
          sa1    lcmccm
          rj     rlc         copy table to scm
 csta     sa1    l.usetab    get current usetab size
          sb2    x1-cmbias*4 expect it to be 12 (3 blocks)
+         eq     b2,*+1
-         ps
          sa1    l.ccom
          lx1    2
          manage usetab,x1   make room for common blocks
          sa1    l.ccom
          zr     x1,csts     if no common blocks
          sb5    x1          count of common blocks to set up
          sa1    lword       set position counter
          sb7    x2+3*4
          sa3    o.ccom
          sa3    x3
          bx6    x1
          lx6    24
          sx7    b0
          sb2    b1
 cstb     bx7    x3
          sa7    b7          set name
          sx7    b2
          sb2    b2+b1
          sa6    a7+b1       set position
          sa7    a6+b1       set common name block index
          sx7    b0
          sa7    a7+b1       clear max org
          sa3    a3+b1       get next common name
          sb7    b7+4
          sb5    b5-b1
          gt     b5,cstb
 csts     sa1    lcmcsm
          zr     x1,cst0     if common symbols not in lcm
          ax1    30
          manage csyms,x1    allocate table in scm
          sa1    lcmcsm
          rj     rlc         copy table to scm
 cst0     sx6    b0
          sa1    qval
          sa6    p1temp
          sa6    a6+b1       p1tempa
          sa6    a6+b1       p1tempb
          bx7    x1
          sa6    a1          set blank qualifier
          sa7    a1+b1
 cst1     sa1    char
          sb7    x1-1r
          zr     b7,cst7     if end of list
          rj     sclist      fetch next item
          zr     x6,cst1     ignore empty field
          sa1    p1temp
          sa6    x1+relvec   store symbol name
          sx7    x1+b1
          sa7    a1
          eq     cst1        loop
 cst3     sa2    o.csyms
          ix1    x1+x2
          sa1    x1          next common symbol
          sa2    p1temp
          sa6    a2+b1
 cst4     zr     x2,cst5     if end of ignore table
          sa4    x2+relvec-1
          sx2    x2-1
          bx6    x1-x4
          nz     x6,cst4     if not ignored
          eq     cst6
 cst5     sa2    a1+b1
          mx4    0
          bx3    x2
          ax3    21
          zr     x3,cst5a    if absolute
          sx3    x3+cmbias
 cst5a    sx5    1s6         set cst bit
          rj     ydefsym
          nz     x6,cst6     if bad symbol
          sa1    cstcnt
          sx6    x1+b1       bump defined common symbol count
          sa6    a1
          eq     cst7
 cst6     sa1    o.csyms     close up common symbol table so
          sa2    p1tempa     it contains only ignored entries
          sa3    a2+b1
          sb7    x1-2
          sa1    x2+b7
          sa2    a1+b1
          sx4    x3+2
          no
          bx6    x1
          lx7    x2
          sa6    x4+b7
          sa7    a6+b1
          bx6    x4
          sa6    a3
 cst7     sa1    p1tempa
          sa2    l.csyms
          sx6    x1+2
          ix2    x1-x2
          nz     x2,cst3     loop to end of common symbol table
          rj     asu         accumulate storage used
          sa1    p1tempb
          sa2    lcmcsm
          sa3    qval+1      store new l.csyms and
          bx6    x1          restore qualifier
          lx7    x3
          sa6    l.csyms
          sa7    a3-b1
          zr     x2,ctl300   if common symbols not in lcm
          mx6    0
          sa6    a6          clear scm table
          sa6    cstcnt
          eq     ctl300      return
          space  4
**        cst - common symbol table.


          qual   pass2
 cst      equ    zlist
*i compass.7490
          rj     gcm         generate common macro text
*i cmp30.2746
          sa7    l.csyms     clear common symbols table
*i cmp30.2749
          sa6    cstcnt
*i cmp042.202
 zend20   sa1    cstcnt
          zr     x1,zend29   if no common symbols defined
          lx1    1
          manage csyms,x1    make room in common symbol table
          ix2    x2+x3
          sa3    cstcnt
          sb7    x3
          sa1    o.symtab
          sa3    o.usetab
          sb3    x3-2
          sb5    -b1
          sb6    59-39
          mx3    60-21
          sx1    x1+b1
 zend21   rx5    x1
          sx4    x1+b5
          sx1    x1+2
          lx6    x5,b6
          pl     x6,zend21   if not a common symbol
          rx4    x4
          bx6    x4
          sx2    x2-2
          sa6    x2
          sb7    b7-b1
          bx7    -x3*x5      copy symbol value
          mx6    60-9
          ax5    21
          bx6    -x6*x5      get relocation
          zr     x6,zend22   if absolute
          lx6    2
          sa5    x6+b3
          lx5    21          position common block ordinal
          bx7    x7+x5
 zend22   sa7    x2+b1
          nz     b7,zend21
          rj     asu         accumulate storage used

 zend29   mx6    0
          sa6    cmbias      mark no common blocks defined from cmtext
*d compass.7738
          sa1    =h*storage used*
*i compass.12655
 gcm      space  4
**        gcm - generate common macro text.
*
*         a common text is like a system text except that there
*         is more stuff in it.  specifically, it includes the
*         following classes of symbols --
*         - absolute symbols
*         - symbols from xtext
*         - common symbols
*
*         the following classes are excluded --
*         - symbols from system text
*         - symbols from common text
*         - qualified symbols
*         - invented symbols (8 chars starting with '?)
*         - relocatable symbols (i.e., block is not a common block)
*         - external symbols
*
*         because common symbols are included in the common
*         text, the names of common blocks are also included in 
*         an additional table in the common text overlay record.
*         it precedes the other four records (which are essentially
*         the same as in a system text overlay).
*
*         note that the location field of the cmtext pseudo specifies
*         the common text output file name, not the overlay name
*         as in the stext pseudo.

 gcm      ps                 return exit
          sa1    cmname
          zr     x1,gcm      if no cmtext generation
          sx6    3
          bx6    x6+x1
          sa6    cp.cfet     set file name in fet

 rm       ifne   cp#rm,0
          env    (4,5,7,8),x
          skip
 x        else
          fetch  cm,oc,x2
          sx6    x2-#yes#
          zr     x6,gcm0aa   if file is open
          openm  cm,output,n
          sa1    cmname
 gcm0aa   bss    0
 x        endif
 rm       endif

          sa2    ercnt
          nz     x2,gcm15    if errors
          sa3    prfx+6
          mx0    30
          bx6    x1          deck name
          sa4    =1ht
          bx3    x0*x3
          lx7    x4
          bx4    -x0*x4
          sa6    dpba+1
          sa7    a3+b1       deck type = t
          bx6    x3+x4
          sa6    a3          target, valid, *f = blanks
          sb4    prfxc
          sb5    prfxc+7
          mx6    0
 +        sa6    b4          clear prfx comment area
          sb4    b4+b1
          lt     b4,b5,*
          sa4    l.segtab    find comment text in idtab
          sa3    o.idtab
          sb7    x3
          mx0    -12
          sx5    x4-5
          sa2    l.idtab
          mi     x5,*+2      if only one segment
 +        sa4    o.segtab
          sa2    x4+5
 +        sb4    prfxc
          sb6    x3+b1
          sb7    b7+x2
 +        sa1    b6          find end of compressed ident statement
          bx6    -x0*x1
          sb6    b6+b1
          nz     x6,*-1
 +        ge     b6,b7,gcm0  if end of comment text
          sa1    b6
          sb6    b6+b1
          bx6    x1
          sa6    b4
          sb4    b4+b1
          lt     b4,b5,*-2   if prfx table not full
 gcm0     sa1    =50000102bs36
          bx6    x1
          sa6    ovlhdr

          ifeq   cp#rm,0,1
          writew cm,prfx,lprfx+1

          sa1    l.usetab
          ax1    1
          manage temtab,x1   temtab has common block table and usetab map
          sx6    -b1
          sa2    o.temtab
          sa6    x2
          sa1    l.usetab
          ax1    2
 gcm0a    sx1    x1-1
          sa6    a6+1
          nz     x1,gcm0a
          sa1    l.usetab
          sa2    o.temtab
          ax1    2           number of usetab entries
          sa1    o.usetab
          sa3    l.usetab
          sb2    -2
          sb3    x3
          sb4    -b1
          sb5    b0
 gcm0b    sb2    b2+4        advance to next usetab entry
          sb4    b4+1        advance mapping index
          ge     b2,b3,gcm0x if end of usetab
          sa3    x1+b2
          zr     x3,gcm0b    if not common block
          sb5    b5+b1
          sa3    a3-2        get common name
          sx7    b5
          bx6    x3
          sa7    x2+b4       set usetab map entry
          sa6    a6+b1       set name
          eq     gcm0b

 gcm0x    sx6    b5
          sa6    a6-b5       set count of common blocks
 rm       ifeq   cp#rm,0
          sa3    o.temtab
          sa2    l.usetab
          ax2    2
          ix3    x3+x2       address of common names buffer
          writew cm,x3,b5+b1
 rm       else
          err                no rm support yet... if ever...
 rm       endif
          sa1    l.symtab    generate system symbol table
          manage duptab,x1+b1
          sb7    x3-1
          sa7    x2
          sb6    x2
          sa4    o.symtab
          sb4    x4+b7
          mx0    12
          mx1    60-21
          sb2    b1+b1
          sa5    =1016bs30
          sb5    59-30
          sb3    -2r'?

*         transfer symbols from symtab to duptab.

 gcm1     zr     b7,gcm2     if end of symbol table
          sx7    b4-b7
          rx2    x7
          sb7    b7-b2
          zr     x2,gcm1     if no symbol
          sx7    x7+b1
          rx3    x7
          bx6    x0*x2
          nz     x6,gcm1     if qualified symbol
          bx6    x2
          ax2    36
          sx4    x2+b3
          sa6    a7+b1
          zr     x4,gcm1     if local symbol
          bx4    x5*x3
          lx7    x3,b5
          nz     x4,gcm1     if set, external, common, or systext
          pl     x7,gcm1     if not defined
          bx7    -x1*x3
          mx4    60-30
          bx4    -x4*x3
          ax4    21
          zr     x4,gcm1x    absolute, ok
          sa3    o.temtab
          ix3    x3+x4
          sa4    x3-1        common map entry for this block
          ng     x4,gcm1     if not common block
          lx4    21          position common block ordinal
          ix7    x7+x4
 gcm1x    sa7    a6+b1
          eq     gcm1        loop
 gcm2     sx6    a7-b6
          sa6    b6

 rm       ifeq   cp#rm,0
          writew cm,b6,x6+b1
 rm       else
          sa1    l.mictab
          sx2    x6+b1       symbol table length
          ix3    x2+x2
          lx2    3           multiply by ten
          ix6    x2+x3
          sa6    t6rm1       save it
          ix2    x1+x1
          lx1    3           multiply micro table length by ten
          ix7    x1+x2
          sa7    a6+b1       save it too
          sx3    10*lprfx+10 add length of prfx + overlay header
          ix5    x6+x7
          sa1    b-1
          ix4    x5+x3
 +        zr     x1,*+1      if record type w
          sx4    0
          store  cm,rl=x4
          putp   cm,prfx,x3
          sa3    t6rm1
          sa2    o.duptab
          putp   cm,x2,x3
 rm       endif

          rj     asu         accumulate storage used
          sx6    b0
          sa6    l.duptab

*         write micro table.

          sa3    l.mictab
          sa2    o.mictab
          sa6    a3
          sx6    x3-1
          sa6    x2          store word count

          ifeq   cp#rm,0,2
          writew cm,x2,x3
          else   2
          sa3    t6rm2       get character count
          putp   cm,x2,x3

*         generate macro name table.

          sa1    l.optab     make room for table
          manage temtab,x1+b1
          rj     asu         accumulate storage used
          sa1    o.optab
          sa2    o.temtab
          sb2    b1+b1
          sb5    x1
          sb6    x1+nopct*2-2
          sb7    x2+b1
          mx0    12
 gcm3     gt     b5,b6,gcm9  if last hash chain finished
          sa1    b5          get first optab entry in chain
          sa2    b5+b1
          sb5    b5+b2       bump chain number
          bx5    x0*x1
          zr     x1,gcm3     if null chain
 gcm4     bx3    x2
          lx2    59-47
          sx4    b1
          bx7    x3          inspect opcode type
          ax3    57
          ix6    x1-x5
          bx4    x3+x4
          lx5    13
          zr     x4,gcm6a    if system or program macro
          mi     x2,gcm6     if program-defined non-macro
 gcm5     zr     x5,gcm3     if end of hash chain
          sa1    b6+x5       get next entry in chain
          sa2    a1+b1
          bx5    x0*x1
          eq     gcm4
 gcm6     sx4    b1          clear program-defined flag
          lx4    47
          eq     gcm7
 gcm6a    sx4    b1          clear program macro flag
          nz     x3,gcm5     if system macro, ignore it
          lx4    57
 gcm7     bx7    -x4*x7      store opcode entry into temtab
          sb4    a1          save address of current entry
          sa1    b5-b2       rescan chain to search for duplicates
 gcm8     sb3    a1
          eq     b3,b4,gcm8a if current entry
          bx3    x0*x1
          ix2    x1-x3       remove hash link
          lx3    13
          bx2    x6-x2
          sa1    b6+x3       get next to compare with current
          nz     x2,gcm8     if not duplicate, loop
          eq     gcm5        duplicate found, ignore current entry
 gcm8a    sa6    b7          no duplicate found, store
          sa7    b7+b1       current entry in temtab
          sb7    b7+b2
          eq     gcm5
 gcm9     sa1    o.temtab    store word count in first word
          sb6    x1
          sx6    b7-b6
          sx7    x6-1
          sa6    l.temtab    reduce table size
          sa7    x1

*         generate macro definition table.

          sx0    b1
          bx2    x7
          mx1    -18
          sb7    57
          lx0    38
          ax6    x0,b1
          bx1    x1-x6       (x1) = mask to clear lcm bit and address
 gcm10    sa3    x2+b6       search macro name table
          zr     x2,gcm14    if end of table
          ax4    x3,b7
          sx5    x4+b1
          sx2    x2-2
          bx6    x0*x3
          nz     x5,gcm10    if not a macro
          zr     x6,gcm11    if not already adjusted
          bx6    -x0*x3
          sa6    a3          clear flag bit
          eq     gcm10
 gcm11    sa4    l.duptab    check for synonyms
          bx6    x1*x3
          ix7    x6+x4       adjust text pointer
          sx5    x2
          sa7    a3
          bx7    x0+x7
 gcm12    zr     x5,gcm13    if end of table
          sa4    x5+b6
          bx6    x3-x4
          sx5    x5-2
          nz     x6,gcm12    if not synonymous
          sa7    a4          set flag bit
          eq     gcm12
 gcm13    sx6    x2          save pointers
          ax7    39
          sa6    p1temp      p1temp  = temtab index
          sa7    a6+b1       p1tempa = text word count
          bx6    -x1*x3      p1tempb = text fwa in macdef or lcm
          sa6    a7+b1
          manage duptab,x7   make room for text
          ix7    x2+x3
          sa1    p1tempa
          sa2    a1+b1
          lx2    59-37
          pl     x2,gcm13a   if in macdef
          lx2    37-59
          sx3    x1
          bx1    x2
          ix2    x7-x3
          rj     rlc         move text from lcm to duptab
          eq     gcm13b
 gcm13a   lx2    37-59
          sa3    o.macdef
          sx1    x1
          ix2    x2+x3
          ix3    x7-x1
          rj     move        move text from macdef to duptab
 gcm13b   sa1    o.temtab
          sa2    p1temp
          sx0    b1
          sb7    57
          sb6    x1
          mx1    -18
          lx0    38
          ax6    x0,b1
          bx1    x1-x6
          nz     x2,gcm10    if not end of macro name table

*         write macro tables.

 rm       ifeq   cp#rm,0

 gcm14    writew cm,l.duptab,1
          sa3    o.duptab
          sa4    l.duptab
          writew x2,x3,x4    write macro definition table
          sa3    o.temtab
          sa4    l.temtab
          writew x2,x3,x4    write macro name table

 rm       else

 gcm14    sa5    l.duptab
          sa4    l.temtab
          sx3    x5+b1       macro defs size + 1 for header word
          ix2    x3+x4
          ix7    x2+x2
          lx2    3
          sa1    b-1
          ix4    x2+x7
 +        zr     x1,*+1      if record type w
          sx4    0
          store  cm,rl=x4
          putp   cm,l.duptab,10
          sa5    l.duptab
          zr     x5,gcm14a   if no macro definitions
          ix7    x5+x5
          lx5    3
          ix3    x5+x7
          sa2    o.duptab
          putp   cm,x2,x3    dump macro definition table
 gcm14a   sa5    l.temtab
          ix7    x5+x5
          lx5    3
          ix3    x5+x7
          sa2    o.temtab
          putp   cm,x2,x3    dump macro name table

 rm       endif

 gcm15    weor   cm
          rj     asu         accumulate storage used
          sx6    b0
          sa6    l.duptab
          sa6    l.temtab
          eq     gcm         return
