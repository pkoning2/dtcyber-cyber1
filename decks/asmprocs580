procs.
user(plato,plato)
settl(*)
setasl(*)
setjsl(*)
attach,procfil/m=w,na.
if(.not.file(procfil,as))define,procfil.
copycf,input,procfil.
~
.proc,ulib,abs,ulib,unam.
.*
.*        procedure to build *ulib* from absolute
.*
.*        abs - file containing absolute.
.*              will contain ulib
.*
.*        ulib - file containing *ulib* header.
.*
.*        unam - *ulib* name.
.*
rewind,old,abs.
skipr,abs.
copyei,abs,old.
note(dir)+*build unam
libedit(i=dir,p=old,lo=e,b=0)
rewind,abs,new,ulib.
skipr,abs.
compass(i=ulib,s=0,l=0,b=ulhdr)
rewind(ulhdr)
copybr,ulhdr,abs.
copyei,new,abs.
unload,dir,old,new,ulhdr.
revert. ulib
.data,ulibm.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*mastor*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for mastor.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
.data,ulibmn.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*mastorn*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for mastorn.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
.data,ulibp.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*plato*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for plato.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
.data,ulibf.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*framat*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for framat.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
.data,ulibc.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*conden*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for condensor.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
.data,ulibplf.
          ident  ulib
          #abs
          nolabel
 
*         form a prefix table
 
 prefix   data   77000016000000000000b
          dis    ,*plf*
          data   10h"date"
          data   10h"time"
          dis    1,
          dis    1,
          dis    1,
          dis    1,
          dis    ,* library for plf.*
          bssz   17b+prefix-*   complete the prefix table
 
*         make a ulib table
 
          data   76000001000000000000b
 
          end
~
.proc,loader,rel,abs,rfl=70000,map=0,mo=sbex.
.*
.*        load relocatable binary, create absolute binary
.*        and save the map.
.*
.*        rel = relocatable binary.
.*
.*        abs = absolute binary.
.*
.*        rfl = running field length for load.
.*
.*        map = pfn, map saved on pfn.
.*        map = 0, map printed, but not saved.
.*
.*        mo = -ldset- map options, default = sb.
.*
unload(#abs)
#rfl(rfl)
ldset(preset=zero,err=all,#map=mo/#map)
load(rel)
nogo(#abs)
purge(abs/na)
define(abs/ct=pu,m=r)
rewind(#abs)
copyei(#abs,abs)
unload(#abs)
.*
.*        copy map to full output file
.*
rewind,#map.
copyei,#map,full.
.*
.*        copy map to permanent file if requested.
.*
ife,(num(map).ne.true),list.
rewind(#map)
purge(map/na)
define(map/ct=pu,m=r)
copyei(#map,map)
endif(list)
.*
unload(#map)
.*
revert. loader
.*
exit.
.*
.*        if errors, copy errors to file *errs* and
.*        copy full map to full output file.
.*
ife(file(#map,eq).ne.0,xedt)
xedit(#map,l=errs)$l.///.*$t$l.***.*$e
rewind,#map.
copy,#map,full.
unload,#map.
endif(xedt)
.*
revert,abort. loader.
~
.proc,condldr,lo=sbex,el=all.
.*
.*  load the condensor.  writes the abs binary to cbin
.*  and the map to cmap.
.*
.*  lo    = ses. link170 list options (default = n).
.*  el    = abort error level (default = all).
.*
.*attach(cmp/m=w,na)
.*if(.not.file(cmp,as))define(cmp/ct=pu)
.*begin(cmpbin,,p=cmp)
.*unload(cmpbin)
.*
.*        on corporate dev systems, include experimental
.*        micro plato version.
.*
ife((r1g.and.200000b)=200000b,exp)
attach(conden,cmp,cl2,cl3,cl4,cl5,cl6/m=r,na)
begin,sespack.
ses. link170 cybclib #lo=lo l=map #el=el ..
xld='ldset(preset=zero)' ..
f=(conden,cmp,cl2,cl3,cl4,cl5,cl6)
unload(conden,cmp,cl2,cl3,cl4,cl5,cl6)
ife(efg.ne.0,loaderr)
xedit(map,l=errs)$l.///.*$t$l.***.*$e
rewind,map.
copy,map,full.
unload,map.
revert(abort) loader errors
endif(loaderr)
.*
.*        otherwise do not include it.
.*
else(exp)
attach(conden,cmp,cl2,cl3,cl4,cl5/m=r)
.*begin,sespack.
.*ses. link170 cybclib #lo=lo l=map #el=el ..
.*xld='ldset(preset=zero)' ..
.*f=(conden,cmp,cl2,cl3,cl4,cl5)
ldset(preset=zero,err=all,map=cmap)
load(conden,cl2,cl3,cl4,cl5)
nogo(cbin)
unload(conden,cmp,cl2,cl3,cl4,cl5)
rewind,map.
copy,map,full.
unload,map.
endif(exp)
.*
purge(cbin,cmap/na)
define(cbin,cmap)
*rewind(lgob,cbin)
*copyei(lgob,cbin,v)
rewind(map,cmap)
copyei(map,cmap,v)
rewind(map)
copyei(map,full)
*
rfl,60000.
begin(ulib,,cbin,ulibc,conden)
catalog(cbin,r,n,u)
.*
.*
unload(lgob,cbin,cmap,map)
.*
revert. condldr
~
.proc,psm,ml=580d,list=0/full.
.*
.*        build plato system modules
.*
.*        entry  ml = nos update level.
.*
unload(lgo)
.*
ife($list$ .eq. $full$,prints)lib
begin,psmbld,,option=orient,binfile=psma,#list.
begin,psmbld,,option=psplus,binfile=psmb,#list.
begin,psmbld,,option=author,binfile=psmc,#list.
begin,psmbld,,option=pcd2,binfile=psmd,#list.
begin,psmbld,,option=srvsys,binfile=psme,#list.
else(prints)
begin,psmbld,,option=orient,binfile=psma.
begin,psmbld,,option=psplus,binfile=psmb.
begin,psmbld,,option=author,binfile=psmc.
begin,psmbld,,option=pcd2,binfile=psmd.
begin,psmbld,,option=srvsys,binfile=psme.
endif(prints)
.*
revert.  psm
~
.proc,psmbld,option,binfile,list=0/full.
.*
.*        build plato system modifier
.*
.*        entry  option = option name
.*               binfile = file name to store binary on
.*
modify(z,lo=e)/*define option/*oplfile nos,ipl/*edit psmd
compass(i,s=nostext,l=list,a)
.*
.*        create new permanent file.
.*
purge(binfile/na)
define(binfile/ct=pu)
rewind,lgo.
copyei,lgo,binfile.
unload,lgo,binfile.
.*
revert.  psmbld
~
.proc,conden,ml=580d,list=0/full.
.*
.*  central condensor full assembly.
.*
.*  exit - conden = relocatable binary.
.*         ccommon = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,#ml=ml)
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(a,i,l=list,s=nostext,s=psstext,#ml=ml)
modify(z,lo=e)/*oplfile nos,ipl/*read edit3
cstc(a,i,l=list,s=0,#ml=ml)
*
*  main overlay.
*
modify(z,lo=e)/*oplfile nos,ipl/*read edit4
cstc(i,l=list,c=ccommon,s=nostext,d,#ml=ml)
*
*  central overlays.
*
modify(z,lo=e)/*oplfile nos,ipl/*read edit5
cstc(i,l=list,c=ccommon,s=0,d,#ml=ml)
*---
rewind(ccommon)
rename(com=ccommon)
purge(ccommon/na)
define(ccommon/ct=pu,m=r)
copy(com,ccommon)
unload(ccommon,com)
.*
purge(conden/na)
define(conden/ct=pu,m=r)
rewind(lgo)
copyei(lgo,conden)
unload(lgo,ccommon,compile,com,edit1,edit2,edit3,edit4,edit5,conden)
revert. conden
.data,edit1.
*edit     conden
.data,edit2.
*edit     csys
.data,edit3.
*edit     defccom
.data,edit4.
*edit     cond
*edit     loadov
*edit     condi
*edit     condc
*edit     consub
*edit     getlin
*edit     conten
*edit     embed
*edit     calcs
*edit     compile
*edit     lex
*edit     deflex
*edit     defsub
*edit     mcond
.data,edit5.
*edit     covlay1
*edit     grafsc
*edit     ansin
*edit     define
*edit     covlay2
*edit     answin
*edit     touchov
*edit     covlay3
*edit     recordc
*edit     sitec
*edit     pptc
*edit     covlay4
*edit     cwrite
.*
.*        in addition to a normal (1,1) plato overlay,
.*        deck *tagov* contains a (1,2) overlay to denote
.*        the end of the central plato overlays.  a *edit
.*        for any new central plato overlay files must be
.*        added before the *edit for *tagov*; otherwise
.*        the new overlay file will not be loaded as part
.*        of the central condensor.
.*
*edit     tagov
~
.proc,conden1,ml=580d,list=0/full.
.*
.*  level 1 micro plato full assembly.
.*
.*  exit - cl1 = relocatable binary.
.*         ccom1 = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(i,l=list,c=ccom1,s=0,d,b=lgo1,#ml=ml)
.*
rename(c1=ccom1)
purge(ccom1/na)
define(ccom1/ct=pu,m=r)
rewind(c1)
copyei(c1,ccom1)
.*
begin(liblvl,,p=lgo1,lvl=1)
.*
unload(edit1,edit2,c1,lgo1,compile,ccom1)
revert. conden1
.*
.data,edit1
*edit     mctxt1
.data,edit2.
*edit     mcond1
*edit     mcond1a
*edit     mcond1b
*edit     mcond1c
*edit     mcond1d
*edit     mcond1e
~
.proc,conden2,ml=580d,list=0/full.
.*
.*  level 2 micro plato full assembly.
.*
.*  exit - cl2 = relocatable binary.
.*         ccom2 = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(i,l=list,c=ccom2,s=0,d,b=lgo2,#ml=ml)
.*
rename(c2=ccom2)
purge(ccom2/na)
define(ccom2/ct=pu,m=r)
rewind(c2)
copyei(c2,ccom2)
.*
begin(liblvl,,p=lgo2,lvl=2)
.*
unload(edit1,edit2,c2,compile,ccom2,lgo2) 
revert. conden2
.*
.data,edit1
*edit     mctxt2
.data,edit2.
*edit     mcond2
*edit     mget2
*edit     mcond2a
*edit     mcond2b
*edit     mcond2c
*edit     mcond2d
*edit     mcond2e
~
.proc,conden3,ml=580d,list=0/full.
.*
.*  level 3 micro plato full assembly.
.*
.*  exit - cl3 = relocatable binary.
.*         ccom3 = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(i,l=list,c=ccom3,s=0,d,b=lgo3,#ml=ml)
.*
unload(compile,edit1,edit2)
.*
rename(c3=ccom3)
purge(ccom3/na)
define(ccom3/ct=pu,m=r)
rewind(c3)
copyei(c3,ccom3)
.*
begin(liblvl,,p=lgo3,lvl=3)
.*
unload(c3,lgo3,ccom3)
revert. conden3
.*
.data,edit1
*edit     mctxt3
.data,edit2.
*edit     mcond3
*edit     mget3
*edit     mcond3a
*edit     mcond3b
*edit     mcond3c
*edit     mcond3d
*edit     mcond3e
~
.proc,conden4,ml=580d,list=0/full.
.*
.*  level 4 micro plato full assembly.
.*
.*  exit - cl4 = relocatable binary.
.*         ccom4 = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(i,l=list,c=ccom4,s=nostext,s=psstext,d,b=lgo4,#ml=ml)
.*
unload(compile,edit1,edit2)
.*
rename(c4=ccom4)
purge(ccom4/na)
define(ccom4/ct=pu,m=r)
rewind(c4)
copyei(c4,ccom4)
.*
begin(liblvl,,p=lgo4,lvl=4)
.*
unload(c4,lgo4,ccom4)
revert. conden4
.*
.data,edit1
*edit     mctxt4
.data,edit2.
*edit     mcond4
*edit     mget4
*edit     mcond4a
*edit     mcond4b
*edit     mcond4c
*edit     mcond4d
*edit     mcond4e
~
.proc,conden5,ml=580d,list=0/full.
.*
.*  level 5 micro plato full assembly.
.*
.*  exit - cl5 = relocatable binary.
.*         ccom5 = common text.
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
.*
modify(z,lo=e)/*oplfile nos,ipl/*read edit2
cstc(i,l=list,c=ccom5,s=nostext,s=psstext,d,b=lgo5,#ml=ml)
.*
unload(compile,edit1,edit2)
.*
rename(c5=ccom5)
purge(ccom5/na)
define(ccom5/ct=pu,m=r)
rewind(c5)
copyei(c5,ccom5)
.*
begin(liblvl,,p=lgo5,lvl=5)
.*
unload(c5,lgo5,ccom5)
revert. conden5
.*
.data,edit1
*edit     mctxt5
.data,edit2.
*edit     mcond5
*edit     mget5
*edit     mcond5a
*edit     mcond5b
*edit     mcond5c
*edit     mcond5d
*edit     mcond5e
~
.proc,conden6,ml=580d,list=0/full.
.*
.*  level 6 micro plato full assembly.
.*
.*  exit - cl6 = relocatable binary.
.*         ccom6 = common text.
.*
begin(level6,,oplfile=$nos,ipl$)
.*
modify(z,lo=e)/*oplfile nos,ipl,l6pl/*read edit1
cstc(a,i,l=list,s=0,b=0,#ml=ml)
modify(z,lo=e)/*oplfile nos,ipl,l6pl/*read edit2
cstc(i,l=list,c=ccom6,s=nostext,s=psstext,d,b=lgo6,#ml=ml)
unload(compile,l6pl,edit1,edit2)
.*
rename(c6=ccom6)
purge(ccom6/na)
define(ccom6/ct=pu,m=r)
rewind(c6)
copyei(c6,ccom6)
.*
begin(liblvl,,p=lgo6,lvl=6)
.*
unload(c6,lgo6,ccom6)
revert. conden6
.*
.data,edit1
*edit     mctxt5
.data,edit2.
*edit     mcond5
*edit     mget5
*edit     mcond5a
*edit     mcond5b
*edit     mcond5c
*edit     mcond5d
*edit     mcond5e
~
.proc,condens,ml=580d,list=0/full.
.*
.*  condensor full assembly.
.*
.*  exit - cbin = absolute binary.
.*
ife($list$ .eq. $full$,prints)
begin(conden,,#ml=ml,#list)
*begin(conden1,,#ml=ml,#list)
begin(conden2,,#ml=ml,#list)
begin(conden3,,#ml=ml,#list)
begin(conden4,,#ml=ml,#list)
begin(conden5,,#ml=ml,#list)
else(prints)
begin(conden,,#ml=ml)
*begin(conden1,,#ml=ml)
begin(conden2,,#ml=ml)
begin(conden3,,#ml=ml)
begin(conden4,,#ml=ml)
begin(conden5,,#ml=ml)
endif(prints)
.*
.*        only assemble the experimental version on the
.*        corporate dev system.
.*
*ife((r1g.and.200000b)=200000b,exp)   if corp dev system
*ife($list$ .eq. $full$,prints)
*begin(conden6,,#ml=ml,#list)
*else(prints)
*begin(conden6,,#ml=ml)
*endif(prints)
*endif(exp)
*
*ife($list$ .eq. $full$,prints)
*begin(condcmp,,#list)
*else(prints)^q
*begin(condcmp)
*endif(prints)
.*
begin(condldr,,lo=sbex)
.*
revert. condens
~
.proc,liblvl,p=,lvl=.
.*
.*  move common relocatable code from the central system
.*  condensor to a micro plato condensor.
.*
.*  p   = micro plato condensor relocatable binary.
.*  lvl = micro plato level.
.*
.*  if p is omitted, cl1, cl2, cl3, cl4, cl5 or cl6 assumed.
.*
attach(conden)
ife($p$.ne.$$,libed)
purge(cl_lvl/na)
define(cl_lvl/ct=pu,m=r)
libedit(#p=p,b=conden,n=cl_lvl,i=edit_lvl,lo=cem)
else(libed)
attach(cl_lvl/m=w)
libedit(#p=cl_lvl,b=conden,c,i=edit_lvl,lo=cem)
endif(libed)
unload(conden,edit1,edit2,edit3,edit4,edit5,edit6,cl_lvl)
revert. liblvl
.data,edit1.
*norep conden
*a rel/mcond1,condc1,getlin,content,embed
*a rel/mcond1,calcs,compile,lex,deflex,defsub
*a rel/mcond1,mcond
.data,edit2.
*norep conden
*a rel/mget2,condc1,lex,mcond
.data,edit3.
*norep conden
*a rel/mget3,condc1,lex,mcond
.data,edit4.
*norep conden
*a rel/mget4,condc1,lex,mcond
.data,edit5.
*norep conden
*a rel/mget5,condc1,lex,mcond
.data,edit6.
*norep conden
*a rel/mget6,condc1,lex,mcond
~
.proc,cmpbin,p=old.
.*
.*  add other condensor idents to the
.*  cmp relocatable binary.
.*
.*  p = cmp relocatable binary file.
.*
attach(cl4/m=r)
attach(conden/m=r)
unload(i)
note(i,nr).*norep conden
note(i,nr).*file conden
note(i,nr).*insert rel/cmpipio,condc1,lex,mcond
note(i,nr).*norep cl4
note(i,nr).*file cl4
note(i,nr).*insert rel/cmpipio,mcond4,mget4
pack(i)
libedit(i=i,#p=p,b=0,l=full,lo=cem,c)
unload(cl4,conden,i)
revert. cmpbin
~
.proc,lc.
.*        load and copy to ubin
load(lgo)
nogo(lgob)
rewind(lgob)
copybf(lgob,tbin)
bksp(tbin)
unload(lgo,lgob,compile)
revert. lc
~
.proc,lcp.
.*        load with presets and copy to ubin
ldset(err=all)
ldset(preset=zero)
load(lgo)
nogo(lgob)
rewind(lgob)
copybf(lgob,tbin)
bksp(tbin)
unload(lgo,lgob,compile)
revert. lcp
~
.proc,cabs.
.*        copy abs programs to ubin
rewind(lgo)
copybf(lgo,tbin)
bksp(tbin)
unload(lgo,compile)
revert. cabs
