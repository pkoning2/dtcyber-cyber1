mods.
user(plato,plato)
settl(*)
setasl(*)
setjsl(*)
rfl,170000.
attach(opl=plaopl)
attach(opl2=opl871)
attach,npl=ipl/m=w,na.
if(.not.file(npl,as))define,npl=ipl.
modify(n,u,c=0)
return(opl)
~
*/ **/---   block=01-e opl2              83/09/22. 20.24    source
*oplfile opl2
*/
*/ **/---   block=01-e nprt              08/07/22. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Make notesfile printing (nprt) work
*/
*/ -------------------------------------------------------------------
*ident nprtfix
*deck nprt
*d nprt.12
     "IDBLKS,IDW(2048),FTITLE(5),IDINFO(20),IPINFO(10),
*d nprt.62,nprt.63
      print 12,MONTH(MON),IDAY,IYR+1900
12    FORMAT(/48X,*NOTES BEGINNING*,A10,I3,*, *,i4)
*d nprt.68
13    FORMAT(/35X,*FILE *,A10,* PRINTED AT *,A10,* ON*,A10,1X,A2,*, 20*,
*d nprt.170
     "IDBLKS,IDW(2048),FTITLE(5),IDINFO(20),IPINFO(10),
*d NPRT.196
20    PRINT 30,MON,IDAY,IYR+1900,HROUT,ICOLON,MIN,APE,
*d NPRT.199
21    PRINT 31,MON,IDAY,IYR+1900,HROUT,ICOLON,MIN,APE,
*d NPRT.202
22    PRINT 32,MON,IDAY,IYR+1900,HROUT,ICOLON,MIN,APE,
*d NPRT.205
23    PRINT 33,MON,IDAY,IYR+1900,HROUT,ICOLON,MIN,APE,
*d nprt.209
30    FORMAT(12X,I2,*/*,I1,*/*,I4,3X,I2,A1,*0*,I1,1X,A2,5X,
*d nprt.211
31    FORMAT(12X,I2,*/*,I1,*/*,I4,3X,I2,A1,I2,1X,A2,5X,
*d nprt.213
32    FORMAT(12X,I2,*/*,I2,*/*,I4,2X,I2,A1,*0*,I1,1X,A2,5X,
*d nprt.215
33    FORMAT(12X,I2,*/*,I2,*/*,I4,2X,I2,A1,I2,1X,A2,5X,
*d nprt.241
     "IDBLKS,IDW(2048),FTITLE(5),IDINFO(20),IPINFO(10),
*d NPRT.320
 DW       BSS    2048        DIRECTORY WORDS
*d nprt.464,nprt.466
 NOSUB    SX2    X1-2048     CANT BE OVER 2047
          NG     X2,DBD1
          SX1    2047
*d NPRT.870
 NCB      EQU    10          NUMBER OF ECS BLOCK BUFFERS                
*/ end nprt
*/
*/ **/---   block=01-e notesys           07/08/29. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Give "notesys" *wrt* privileges
*/
*/ -------------------------------------------------------------------
*ident notesys
*deck sysless
*d SYSL95A.181
          LTYPE  NOTESYS,(BIN,SYS,wrt,D2,SYSNV)
*/ end notesys
*/
*/ **/---   block=01-e jsfont           07/05/24. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Turn on -font- for pterm
*/
*/ -------------------------------------------------------------------
*ident jsfont
*deck pftext
*i arrows.5
sbtpterm equ    16          pterm for cyber1 software
*/ end pftext
*deck exec3
*i nexec3.757
          title  send font ext codes to ASCII pterm only
***       fontext  -  sends ext codes to pterm
*
*         uses a - 1
*              b - 1,2
*              x - 0,1
*
*         input: b1 = ext code
*                b2 = value to be added to ext
*
*
          entry  fontext
 fontext  eq     *           entry/exit
          sa1    stflag1     get terminal info word
          mx0    -ttbtn      set mask for term type field
          lx1    ttbtn-ttbts  position term type field
          bx0    -x0*x1      get term type
          sx0    x0-asctype  see if ascii term (ztttype=12)
          nz     x0,fontext  if not ascii, exit
          sa1    bankadd     get word holding term subtype
          mx0    -tsbtn      set mask to get data
          lx1    tsbtn-tsbts  position data to end of word
          bx1    -x0*x1      mask out term subtype
          sx0    x1-sbtwin   see if windows terminal
          zr     x0,fontext1 send -ext- code
          sx0    x1-sbtmac   see if macintosh system
          zr     x0,fontext1 send -ext- code
          sx0    x1-sbtpterm see if pterm terminal
          zr     x0,fontext1 send -ext- code
          eq     fontext     -- return

 fontext1 sx1    b1          -ext- code
          sx1    x1+b2       add additional value to -ext-
          outcode extcode    output code to formatter
          eq     fontext     return
*d font.39
          call   fontext,5000b,x1    font type code
*d font.49
 sendsiz  call   fontext,5100b,x1    font size code
*d font.53
          call   fontext,5200b,x1    font mode code
*/ end exec3
*deck tutorx
*d font.32
          call   fontext,5000b,1     default font
*d font.37,font.38
          call   fontext,5100b,0     default size
          call   fontext,5200b,0     default font mode
*d font.56
          call   fontext,5000b,x1
*d font.68
          call   fontext,5100b,x1
*d font.73
          call   fontext,5200b,x1

*/
*/ **/---   block=01-e tprtuse           07/05/14. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Fix tprint to print -use- commands
*/
*/ -------------------------------------------------------------------
*ident tprtuse
*deck tprta
*yank AI27611
*/
*/ **/---   block=01-e ascii              06/03/28. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Allow ppt commands without fuss
*/
*/ -------------------------------------------------------------------
*ident pptok
*deck condc
*d VCPPT.49,VCPPT.66
*d VCPPT.68,VCPPT.71
*deck covlay2
*d COVLAY2.493
*d COVLAY2.733,COVLAY2.793
*/ end covlay2
*/
*/ **/---   block=01-e ascii              06/03/28. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ make ASCII terminals work if CIU is also present
*/
*/ -------------------------------------------------------------------
*ident ciuasci
*deck outform
*d MISCFX1.5
+         EQ     OUTF555     14 - ASCII terminal
*/ end outform
*/
*/ **/---   block=01-e cerlpack              06/03/28. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Use CERL-style real packs
*/
*/ -------------------------------------------------------------------
*ident cerlpak
*deck mastor
*d JSNPPU.11
          SYSTEM png,,PNGWRD
*/ end mastor
*/
*/ **/---   block=01-e hostname              06/03/28. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Get system name from the environment.
*/
*/ -------------------------------------------------------------------
*ident hostnam
*deck instalp
*d instalp.81
 HOMESYS  DATA   0
*/ end instalp
*deck,msubs
*i msubs.7

 exx      cpop   0,016b,012b
*i msubsa.8

***       default rid values corresponding to devsys names
 defrid   data   0
          data   0
          data   0
          data   0
          data   0lcy1
          data   0lbrs
          data   0lgpk

 hostreq  vfd    48/0,12/0   getenv
          data   0lhostname
*i msubsa.22
          nz     x3,chkdev   if system name set
          sx1    hostreq     point to getenv request block
          ex3    x1          get hostname from environment
          bx6    x3
          sa6    a3          set system name
*i msubsa.31
          sa3    homerid     check home rid definition
          nz     x3,savedev  if rid set
          sa1    defrid-1+x0 get default rid for this system name 
          bx7    x1
          sa7    a3
*d msubs.1957,msubs.1961
*/ end msubs
*deck tovlay
*d tovlay.481,tovlay.502
          sa2    =xhomerid   (X2) = route id
          lx2    18          right-justify it
*d TOVLAY.948,tovlay.952
*/ end tovlay
*/
*/ **/---   block=01-e logout              05/11/02. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Send out nopcode 3 when logout is being done, so the niu knows
*/ about that and can stop sending offkey.
*/
*/ -------------------------------------------------------------------
*ident logout
*deck fovlay1
*i fovlay1.1178
          sx7    3
          packwrd x7         send *logging out* pterm nop
*deck fovlay3
*i fovlay3.1166
          sx7    3
          packwrd x7         send *logging out* pterm nop
*deck fovlay4
*i fovlay4.1308
          sx7    3
          packwrd x7         send *logging out* pterm nop
*deck main
*d main.1576
          PL     X2,pkeyt1   if higher than touch range
*i main.1578
*
* * *     check for *offky2*
*
 pkeyt1   sx2    x1-offky2
          nz     x2,pkeyt2   if not *offky2*
          outp   fincode     tell NIU that we are logged out already
          call   patut
          sx1    next        treat it as next to sign in
          eq     pkeytype
*d main.1582
 pkeyt2   SX2    X1-ABORTK
*/ end logout
*/
*/ **/---   block=01-e nocmp              05/09/30. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Do not crash on missing conden overlays (like central tutor or
*/ development level)
*/
*/ -------------------------------------------------------------------
*ident nocmp
*deck cond
*i cond.152
          sx6    33          Condense error code for *cmp not available*
          zr     X1,CMPGO3   IF CMP absent
*i cond.306
          zr     X1,BADLEV   If this level not built into this conden

*/ end nocmp
*/
*/
*/ **/---   block=01-e dtxon              05/08/17. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Add xon/xoff processing.  These keys are generated in pterm
*/ when its terminal word buffer is close to full.
*/
*/ -------------------------------------------------------------------
*ident dtxon
*deck paramc
*i paramc.168
 xonkey   equ    1606b       xon  key value
 xofkey   equ    1607b       xoff key value
*/ end paramc
*/
*deck pftext
*i pftext.287
 xofbit   equ    58          bit 57 = output off
*d pftext.290
*                            BITS 42-56 UNUSED
*/ end pftext
*/
*deck main
*i main.1669
          sx2    x1-timeup
          zr     x2,pkeyp1
          sx2    x1-catchup
          zr     x2,pkeyp1
          sx2    x1-timeup
          mi     x2,pkeyp0   if keyset key
          eq     pkeyp1      all others leave xofbut alone
          sx2    x1-400b
          mi     x2,pkeyp1
          sx2    x1-3400b
          mi     x2,pkeyp0
          sx2    x1-3500
          mi     x2,pkeyp1
 pkeyp0   sa2    bankadd
          mx6    1
          lx6    xofbit      position to *xoff* bit
          bx6    -x6*x2      clear *xoff*
          sa6    a2
 pkeyp1   bss    0
*i main.1774
*
* check for *xofkey* and *xonkey*
*
          sx2    x1-xofkey
          zr     x2,xpxoff   if -xofkey-
          sx2    x1-xonkey
          zr     x2,xpxon    if -xonkey-
*i main.1903
*
 xpxoff   sa2    bankadd
          mx6    1
          lx6    xofbit      position to *xoff* bit
          bx6    x6+x2       set *xoff*
          sa6    a2
          eq     xpkey2      write back station bank
*
 xpxon    sa2    bankadd
          mx6    1
          lx6    xofbit      position to *xoff* bit
          bx6    -x6*x2      clear *xoff*
          sa6    a2
          eq     xpkey       write back station bank
*/ end main
*/
*deck logicx
*i logicx.864
          sa1    bankadd
          lx1    60-xofbit
          mi     x1,jpe200   if *xoff* in effect
*/ end logicx
*/
*deck tutorx
*i XKREORG.369
          sa1    bankadd
          lx1    60-xofbit
          mi     x1,tfinoo   if *xoff* in effect
*i XKREORG.427
          sx2    x1-xonkey   check for *xon* key
          zr     x2,tfinp1
*i XKREORG.444
          sa1    bankadd
          lx1    60-xofbit
          mi     x1,tfinoo   if *xoff* in effect
*d XKREORG.463
 tfinoo   SB1    -1          -1 = WAIT FOR KEY
*/end tutorx
*/
*deck mainov
*i mainov.290
          mx1    1
          lx1    xofbit      position to *xoff* bit
          bx6    -x1*x6      clear *xoff*
*/end mainov
*/
*/ **/---   block=01-e dd60hlp              05/08/03. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Fix right screen display for Console.
*/
*/ -------------------------------------------------------------------
*ident dd60hlp
*deck dd60
*d dd60.1179,dd60.1181
,,    .    (    ))
*/ end dd60
*/
*/ **/---   block=01-e blkeras              05/02/08. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Remove filler nop*s after block erase for PPT terminals.
*/
*/ -------------------------------------------------------------------
*ident blkeras
*deck fovlay4
*d fovlay4.577,fovlay4.591
*d fovlay4.593,fovlay4.601
*d fovlay4.628,fovlay4.633
*d fovlay4.635,fovlay4.638
*d fovlay4.1372,fovlay4.1410
          eq     outloop
*/
*/ **/---   block=01-e dterase              05/02/08. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Send nop code with data 2 to indicate output has been aborted
*/ (for -erase abort- and stop key).  That allows pterm to discard
*/ buffered output.  There can be a lot of that when it is processing
*/ -delay- nops or other timed data.
*/
*/ -------------------------------------------------------------------
*ident dterase
*deck putilty
*i putilty.276
          sx7    2
          packwrd x7         send *abort output* pterm nop
*/ end putilty
*/
*/ **/---   block=01-e bdspsdm              05/01/22. 12.00    source
*/ -------------------------------------------------------------------
*/
*/ Remove check for SDM= entry point in B display retrieval
*/
*/ -------------------------------------------------------------------
*ident bdspsdm
*deck mrq1
*d mrq1.2683,mrq1.2684
*d mrq1.2937,mrq1.2949
*d mrq1.2985,mrq1.2986
*/ end mrq1
*/
*/ **/---   block=01-e cfo              05/01/21. 15.00    source
*/ -------------------------------------------------------------------
*/
*/ Reinstate the "CFO type-in" MRQ request, so chess4p2 will work.
*/
*/ -------------------------------------------------------------------
*ident cfo
*deck plasmrq
*i PLASMRQ.39
 mr.jcfo  EQU    21          enter CFO type-in
*/ end plasmrq
*/
*deck mastor
*d mastor.2234
 MRQREQ   BSSZ   6           *MRQ* REQUEST AREA
*deck mastor2
*i mastor2.629
          SA1    PARAM4
          BX6    X1
          SA6    MRQREQ+3
          SA1    PARAM5
          BX6    X1
          SA6    MRQREQ+4
          SA1    PARAM6
          BX6    X1
          SA6    MRQREQ+5
*i mastor2.659
+         VFD    48/0LCFO,12/mr.jcfo
*/ end mastor2
*/
*deck mrq
*i mrq.147
*         REQUEST TYPE = 21 = enter CFO message
*         12/21, 36/0, 12/0
*         42/JOB NAME, 18/0
*         60/msg
*         60/msg
*         60/msg
*         36/msg, 24/0
*
*i mrq.508
          REQTAB JMACT,0,1     21 = enter CFO type-in
*d mrq.511
*i mrq.512
 .NOSV2   ENDIF
*/ end mrq
*/
*deck mrq1
*d mrq1.4807
*                   20 = PURGE QUEUE FILE (NOS 1 only)
*                   21 = Enter CFO type-in (NOS 2 only)
*d mrq1.4814
          sbn    2
          mjn    *+3         if abort or cfo
*i mrq1.4839

          ldm    ii
          njn    jma200      CFO type-in
*i mrq1.4852

*
*         Enter CFO type-in for specified job
*

 jma200   ldd    cn+4        pick up job status
          lpn    76b
          lmn    /ejt/exjs*2   check for executing
          njn    jmerr2      if not executing
          ldn    4
          std    d.t0
          RJM    LOADPPW     GET ADDRESS OF REQUEST WORD
          adn    2           point to the typein data
          crm    cfobuf,d.t0 read four words of typein data
          SFA    EJT,CM+2    COMPUTE ADDR OF EJT ENTRY
          ADK    SCHE        PLUS BIAS FOR scheduling data
          CRD    CN
          ldd    cn+3        get cp number
          shn    7
          adn    flsw
          crd    cm          read ra from cp area
          ldd    cm+3
          shn    6
          adn    ccdr        form address of cfo area
          cwm    cfobuf,d.t0 write cfo message
          ldd    cm+3
          shn    6
          crd    cn          read job ra+0
          ldd    cn+3
          lpc    -5          clear cfo and pause bits
          std    cn+3
          ldd    cm+3
          shn    6
          cwd    cn          rewrite ra+0 for job
          ujp    mrqrx       success

 cfobuf   bss    4*5         space for cfo data (36 chars max)
*/ end mrq1
*/
*/ **/---   block=01-e bigkeys              05/01/13. 12.19    source
*/ -------------------------------------------------------------------
*/
*/ Make the key buffer larger and parameterize things right to get
*/ rid of hardwired constant offsets.
*/
*/ The old key buffer layout goes like this
*/        vfd    12/key0, 12/key1, 12/key2, 12/key3, 12/ppuindex
*/        vfd    36/ , 12/stop1code, 12/cpuindex
*/ and the offsets to the index fields (cpu offsets 0 and 1, ppu
*/ offsets 4 and 9) were written as simple numbers.  For that matter
*/ the wraparound was by masking the index with literal 3... and the
*/ size of the keybuf entry was handled as hardwired 2 via a shift of 1.
*/
*/ The new code does everything symbolically.  All you have to do to
*/ change the key buffer size is to specify a new value for NKEYSHF.
*/ (The key buffer size is a power of two, NKEYSHF is that power.)
*/
*/ -------------------------------------------------------------------
*ident bigkeys
*/
*/ the symbol definitions come first, then the actual code.
*/
*deck syscon
*i syscon.72
*
*         key buffer length related parameters.
*         these were formerly defined in polls and several other
*         plato source files.

 NKEYSHF  EQU    3           STATION SHIFT COUNT TO ADDRESS KEY BUFFER

* derived values

 mkeyshf  decmic nkeyshf
 nkeylth  equ    1S"mkeyshf" length of key input buffer (cp words)
 pkeylth  equ    nkeylth*5   length of key input buffer (pp words)
 nkcpidx  equ    nkeylth-1   cp offset to word with cp index
 pkcpidx  equ    pkeylth-1   pp offset to cp index word
 pkstop1  equ    pkeylth-2   pp offset to stop1 and fastkey word
 nkppidx  equ    nkeylth-2   cp offset to word with pp index
 pkppidx  equ    pkeylth-6   pp offset to pp index word
 idxlim   equ    pkppidx     index limit (highest value + 1)

* macro for building table of cpu offset and shift given index

 kxmac    if     -mac,kidxtb  avoids warning in psys
 kidxtb   macro
 zzzzix   set    0
 zzzzwd   set    0
 zzzzsh   set    12
 kidxwd   dup    idxlim
          vfd    12/2000b+zzzzsh,48/zzzzwd
 zzzzsh   set    zzzzsh+12
          ifgt   zzzzsh,60,2
 zzzzsh   set    12
 zzzzwd   set    zzzzwd+1
 kidxwd   endd
 kidxtb   endm
 kxmac    endif
*/
*/ Now the code changes
*/
*deck pftext
*d pftext.67
*/ end pftext
*/
*deck pio
*d PIO.81
 KEYBSHF  EQU    nkeyshf       SHIFT FOR KEY BUFFER DIMENSION
*d pio.772
          LDN    pkeylth
*d pio.781
          LDM    ECSBUFF+pkstop1  GET STOP1 CODE
*d pio.866
          LDM    ECSBUFF+pkstop1  FIRST CHECK FOR STOP1
*d pio.925
          LDN    pkeylth
*d pio.930,pio.931
 KYO210   LDM    ECSBUFF+pkppidx  PPU INDEX IN KEY BUFFER
          SBM    ECSBUFF+pkcpidx  CPU INDEX IN KEY BUFFER
*d pio.934
          ADC    idxlim      adjust for wrap
*d pio.936
 KYO220   lmn    idxlim-1    check for index limit
*d pio.938
          LDM    ECSBUFF+pkstop1  LOAD -STOP1- KEY VALUE
*d pio.942
*d pio.947,pio.949
 KYO225   AOM    ECSBUFF+pkppidx  INCREMENT PPU KEY BUFFER INDEX
          lmn    idxlim      check for wrap
          njn    kyo227      if not wrap
          stm    ecsbuff+pkppidx  wrap back to start of buffer
 KYO227   LDM    ECSBUFF+pkppidx
          STD    D.T4        set keybuf offset
*d pio.952
*/ ideally we would write just the one word that changed, but that
*/ involves a divide by 5 so we do not bother for now.
          LDN    pkeylth-5   D.T3 = NUMBER WORDS TO WRITE
*d pio.1874
 ecsbsz   max    pkeylth,10
 ECSBUFF  BSS    ecsbsz      BUFFER FOR ECS READ/WRITE
*/ end pio
*/
*deck dd60
*d dd60.568
 KB2A     bssz   nkeylth     KEY BUFFER
*d dd60.644,dd60.648
          SX0    X4+LSTUD*nkeylth
+         re     nkeylth
-         RJ     ECSPRTY
          sa3    a0+nkppidx  get ppu index word
          sa4    a0+nkcpidx  get cpu index word
*d dd60.652,dd60.653
          sx6    X6+1        INCREMENT PP index
*d dd60.655,dd60.662
          sb6    x6-idxlim
          mi     b6,kbi1     if not time to wrap
          sx6    0           wrap to start
 kbi1     bx7    x6-x0       check against cp index
          zr     x7,kbix     no room, exit
          bx7    x5*x3       get rest of word with pp index
          bx7    x7+x6       merge updated index
          sa7    a3          update pp index word
          sa3    x6+kidxtb   read word and shift for this index
          ux3,b7 x3
          sa3    x3+kb2a     fetch the right word
*d dd60.669,dd60.674
          SA6    a3
*d dd60.676,dd60.677
          SX0    X4+LSTUD*nkeylth
+         we     nkeylth-1   write ecs keybuf except for cpu index word
*i dd60.682

 kidxtb   kidxtb
*/ end dd60
*/
*deck msubs
*d msubs.293
          SX3    nkeylth     NUMBER OF WORDS PER KEY BUFFER.
*d msubs.297
+         WE     nkeylth     WRITE OUT NEW BUFFER
*d msubs.477
 IIIKEY   BSSZ   nkeylth-1
*d msubs.2054
          SX7    nkeylth
*/ end msubs
*/
*deck polls
*d polls.12,polls.25
*d polls.64,polls.70
*    WORD 0    12 / key 0
*              12 / key 1
*              12 / key 2
*              12 / key 3
*              12 / key 4
*    ... ditto words 1 .. n-2
*
*    WORD N-1  12 / KEY K-3
*              12 / KEY K-2
*              12 / KEY K-1
*              12 / KEY K
*              12 / PPU KEY POINTER
*
*    WORD N    36 / TIME AND PRESS KEY INFORMATION
*i polls.79
*    where n is (1 $cls$ nkeyshf) - 1.
*d polls.279
          SA2    A0+nkppidx  X2 = KEY STORAGE WORD (AND PPU KEY INDEX)
          SA4    A0+nkcpidx  X4 = CPU KEY WORD
*d polls.281
*d polls.362
          sx7    x5-idxlim   test for index limit
          mi     x7,notimw   if not wrap
          sx5    0           wrap back to start of buffer
 notimw   SA1    STFLAG1     TEST FOR NEW-TYPE KEY PROCESSING
*d polls.369,polls.376
 notima   sa2    x5+kidxtb   read word and shift for this index
          ux2,b2 x2
          sa2    x2+keyinfo  fetch the right word
          lx6    x2,b2       shift key into bottom 12 bits
*i polls.383
          sx7    x5-idxlim   test for buffer wrap
          mi     x7,notima   if not wrap
          sx5    0           wrap back to start of buffer
*d polls.391,polls.398
          sa2    x5+kidxtb   read word and shift for this index
          ux2,b2 x2
          sa2    x2+keyinfo  fetch the right word
          lx6    x2,b2       shift key into bottom 12 bits
*d polls.457
 RETCP    SX1    nkcpidx     offset to cpu index
*d pollrwx.14
          SA1    A0+nkcpidx  UPDATED CPU KEY INDEX WORD
*i polls.480

 kidxtb   kidxtb
*d polls.503,polls.504
          SA1    A0+nkppidx  PPU KEY WORD
          SA2    A0+nkcpidx  CPU KEY WORD
*d UQ9600.21,UQ9600.22
          SA1    A0+nkppidx  PPU KEY WORD
          SA2    A0+nkcpidx  CPU KEY WORD
*i UQ9600.25
          pl     x6,keycnt   if no wrap
          sx6    x6+idxlim   adjust count for wrapped index
*d polls.570
          SA2    A0+nkcpidx  X2 = CPU KEY WORD
*d pollrwx.17
          SX1    nkcpidx     offset to cpu index
*d polls.1041
          SA1    KEYINFO+nkcpidx  (X1) = CPU KEY BUFFER WORD
*d polls.1053
          SX1    nkcpidx     offset to cpu index
*d polls.1168
          SA5    A0+nkcpidx  X5 = CP WORD OF BUFFER
*d pollrwx.40
          sx4    nkcpidx     offset to cpu index
*d polls.1232
          SA1    A0+nkppidx  LOAD PPU KEY BUFFER WORD
*d polls.1234
          SA2    A0+nkcpidx  LOAD CPU KEY BUFFER WORD
*d polls.1266
          WE     nkeylth
*d polls.1269
          RE     nkeylth
*d polls.1273
 IIIKEY   BSSZ   nkeylth-1
*/ end polls
*/
*deck exec6
*d exec6.4158
          SA1    A0+nkcpidx  X1 = CPU index word OF KEYBUFFER
*d exec6.4163
          SX1    nkcpidx     offset to cpu index
*d exec6.4165,exec6.4166
          sa0    a0+nkcpidx
+         we     1           write it back to ecs
*d exec6.4292
          SA1    A0+nkcpidx  X1 = CPU index word OF KEYBUFFER
*d exec6.4297
          SX1    nkcpidx     offset to cpu index
*d exec6.4299,exec6.4300
          sa0    a0+nkcpidx
+         we     1           write it back to ecs
*d exec6.4320,exec6.4322
*d exec6.4327
 FKKEYBF  OVDATA nkeylth
*/ end exec6
*deck pni2
*d JBFKEY.154
          LX1    /plat/nkeyshf
*d jbfkey.156,jbfkey.157
          sa0    cmkbuf      address of cm copy of key buffer
          RE     /plat/nkeylth READ KEY BUFFER ENTRY
*d jbfkey.159,jbfkey.160
          SA1    A0+/plat/nkppidx  net KEY WORD
          SA3    A0+/plat/nkcpidx  CPU KEY WORD
*d jbfkey.164,jbfkey.167
          sb6    x3-/plat/idxlim
          mi     b6,sky9     if not time to wrap
          sx3    0           wrap to start
 sky9     bx6    x3-x4       check against cpu index
*d jbfkey.172,PNIRWX.24
          bx6    x7*x1       get rest of word with net index
          bx6    x6+x3       merge updated index
          sa6    a1          update net index word
          sa3    x3+kidxtb   read word and shift for this index
          ux3,b6 x3
          sa3    x3+cmkbuf   fetch the right word
          lx3    b6          put the key byte to update in low byte
          bx3    x3*x7       clear it out
          bx3    x2+x3       merge the key
          sb6    b6-60
          ax6    x3,b6       rotate key word back to the way it was
          SA6    a3
+         we     /plat/nkeylth-1 write ecs keybuf except for cpu index word
-         rj     epe
*i JBFKEY.219

 cmkbuf   bss    /plat/nkeylth

 kidxtb   bss    0
          qual   plat
          kidxtb
          qual   *

*/ end pni2
*/
*/ **/---   block=01-e signoff              05/01/13. 12.19    source
*/ -------------------------------------------------------------------
*/
*/ Treat the disconnect key as special, so it always gets through
*/
*/ -------------------------------------------------------------------
*ident signof2
*deck pio
*i PIO.740
          LDM    KEYBUFF+1,D.T0   LOAD KEY WORD
          STD    KEY
          lmc    1753B*2     check *offky2* value (immediate off)
          zjn    kyo150      if *offky2*, bypass flooding check
*d PIO.754,PIO.755
*i PIO.937
          ldd    key
          lmc    1753B*2     check *offky2* value (immediate off)
          zjn    kyo227      if *offky2*, overwrite last key
*/ end pio
*/
*/ **/---   block=01-e no acct              04/12/06. 12.19    source
*/ -------------------------------------------------------------------
*/
*/ turn off detailed accounting
*/
*/ -------------------------------------------------------------------
*ident dtacct
*deck instalp
*delete instalp.49
 ACCON    DATA   0           ACCOUNTING OFF
*/ end instalp
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e nopcode              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ send nop words (word value 1) for nopcode
*/
*/ for now, change only plato iv overlay
*/
*/ -------------------------------------------------------------------
*ident dtnop
*deck fovlay1
*delete fovlay1.898
          sx7    1
          packwrd x7         send terminal nop
*/ end fovlay1
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e frame1024              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ increase frame count to 1024 (was 128) and mout buffer to 1000
*/ (was 512)
*/
*/ -------------------------------------------------------------------
*ident fram1k
*deck pftext
*delete vgtext.1
 moutlth  equ    1000d       usable *mout* area (arbitrary)
*delete pftext.33,pftext.34
 nframs   equ    1024d        number of frames
 nfrmshf  equ    10d
*/ end pftext
*/
*deck pio
*delete pio.72
*         fmask   - nfrmshf/nframs
*delete pio.80
 fmask    equ    1777b       mask for frame index
*/ end pio
*/
*deck ftext
*delete ftext.362
* this takes two steps because *max* produces a redefinable
* symbol, and those are not saved in the cmtext.
 outbl.   max    mdismax+4,nframs
 outblth  equ    outbl.
*/ end ftext
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e fastniu              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ change framat-pio interface so dtcyber emulated niu works correctly
*/ when running without rate limiting.
*/
*/ the effect of the lack of rate limiting is that pio can get ahead
*/ of framat, unlike the classic hardware which needed 16.66 ms to
*/ send a frame and would not accept another one until that time is up.
*/ the framat-pio communication assumed that it would not be possible
*/ for pio to finish one frame and go on to the next in less time than
*/ it would take framat to frame all the pending output for a station.
*/ if there is a lot of output to frame, that is no longer true when
*/ the niu frame pacing is taken out of the picture.
*/
*/ solution: (a) update the frame counters all the time.  (b) add
*/ a framat-pio interlock variable, 2 ecs words right after the
*/ pio frame counter words (one per niu).  framat sets that word
*/ non-zero while it is filling the frame buffer chain for a station,
*/ starting just before it reads the ppu frame counter, and ending
*/ after it has written the updated frame lengths.  if the interlock
*/ is set, pio waits exactly as it would clasically when the niu is
*/ not yet ready for a new frame.
*/
*/ note that the error correction code paths are not handled in this
*/ patch, because they are not used in the emulated environment.
*/
*/ -------------------------------------------------------------------
*ident fastniu
*deck format
*delete format.297,format.304
*/ end format
*/
*deck pio
*insert pio.28
*             the framat-pio framing interlock is at offset +2 from here.
*delete pio.268,pio.270
*         wait for framat-pio framing interlock to be clear
*
 m110     ldc    ecsbuff
          std    d.t0        d.t0 = ppu memory address
          ldm    ecra+1      compute ecs addr of interlock
          adm    outpnt+1
          adn    2           +2 for interlock
          std    d.t2        d.t2 = lower part of ecs addr
          shn    -12
          adm    ecra
          adm    outpnt
          std    d.t1        d.t1 = upper part of ecs addr
          ldn    5
          std    d.t3        d.t3 = number words to read
          call   readecs     read interlock
          ldm    ecsbuff+4
          njp    main        if interlock set
*
*         attempt to select ciu and output no-op
*
          ijm    m112,o=niu
*/ end pio
*/
*deck platxt
*delete platxt.671
 aframpt  ecsbuf 4           frame counters and framer-pio interlocks
*/ end platxt
*/
*deck format
*insert format.2034
          sa2    xfrmpnt
          sx3    2
          mx6    0
          ix3    x2+x3       form address of interlock
          wx6    x3          clear pio interlock (may chg *a6*)

*delete format.2042
          sa2    xfrmpnt
          sx3    2
          sx6    1
          ix3    x2+x3       form address of interlock
          wx6    x3          set pio interlock (may chg *a6*)
          rx2    x2          read current pio frame ctr (may chg *a2*)
          ix3    x1-x2       check pio against framat pointers
          pl     x3,ftw050   if framat not behind
          bx1    x2          start framing from next pio frame
          bx3    -x3         number of frames pio is ahead
          sb6    x3          pretend to caller we used that much extra

 ftw050   mx0    -nfrmshf
*/ this one line change is a documentation fix
*delete for180.35
 setf     sa2    xfrmpnt     ecs address of pio frame counter
*/ end format
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e back2exit              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ remove "press -back- to exit"
*/
*/ -------------------------------------------------------------------
*deck mainov
*yank pbte
*/ end mainov
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e systype              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ set os level and system type
*/
*/ -------------------------------------------------------------------
*deck syscon
*delete jsnppu.28
*/
*/ we call it 180, not 170, even though we really are not.
*/ the only difference is that rx and wx instructions
*/ are enabled, which is required or fovlay5 does not fit.
*/ (the other difference is that some necessary code in pms
*/ disappears, but the mod below, deleting pms800 1-4, cures that.)
*/
 machine  micro  1,3,/180/   cyber 180 or cyber 170 system

*                os level

          if     -mic,noslvl,1
 noslvl   micro  1,,/"modlevel"/

*                production or development

 dev      equ    0           production system

*/ end syscon
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e nos2.1              83/09/22. 20.24    source
*/ -------------------------------------------------------------------
*/
*/ some edits needed to make things build on nos 2.1-580.
*/
*/ it turns out that some of these are required for 2.8.7 too -- perhaps
*/ the code in dsn was simply just wrong.
*/
*/ -------------------------------------------------------------------
*ident miscfix
*deck dsn1
*delete dsn1.191
          errnz  stbkl-28d  station bank length .ne. 28d
*delete dsn1.204
*/ end dsn
*deck pms
*yank pms800
*/ delete 180 specific code to make room
*d PMS.2095,PMS.2136
 rlp1     equ    relddpx
*/ we do need a few lines from that mod:
*i pms.2477
 .NOS282  IFGE   OSLEV,826D
 PDA      HERE               INSERT *PDA* SUBR FROM COMPLDA
 .NOS282  ENDIF
*/ end pms
*/
*/ -------------------------------------------------------------------
*/ **/---   block=01-e restfaa              83/09/22. 20.24    text
*/ -------------------------------------------------------------------
*/ -------------------------------------------------------------------
*/
*/ the remaining mods are taken from *plmods* from faa.
*/
*/ -------------------------------------------------------------------
*/
*/ **/---   block=01-e platlvl              83/09/22. 20.24    source
*ident,cyb97b
*deck,placsmd
*d,cyb97a.1
 platlvl  micro  1,,/99'a/
*/ **/---   block=01-g pni800x              81/05/27. 16.21    source
*/ -------------------------------------------------------------------
*ident,pni800x
*deck,pni2
*d,pni2.37,pni2.39
*call     comccmd
*call     comcmac
*call     comsprd
*call     comccvl
*i,xtipc.55
* /---   block      pnii       00 000   81/05/27  13.32
*i,pni2.1333
*         determine if running on a170 system or not

          getmc  mcbuf       get machine characteristics
          sa1    mcbuf       (x1) = word with 170/835 status
          mx0    -1
          lx0    20          position mask under 170/835 bit
          bx6    -x0*x1      (x6) = 170/835 status flag
          sa6    a170

*i,pni2.1357

          sa1    a170
          nz     x1,pnia170  if a170, skip reset

*d,vgmpni.13
 pnia170  sa1    actr
*d,bjsac.11
*i,vgmpni.30
* /---   block      pnii       00 000   81/05/27  13.31
*d,jsnppu.5
*i,vgmpni.64
*
 mcbuf    con    0           machine id return word
 a170     con    0           a170 status word
*
* /---   block      pnii       00 000   81/05/27  13.30
*d,pni2.1836,pni2.1841

 wcb6a    bx6    x1          save *x1*
          sa1    a170
          nz     x1,wcb7     if a170 system, skip

+         re     1
          eq     *           re-try on reject

 wcb7     bx1    x6          restore *x1*
          bx0    x1          save buffer pointer
          recall             pause
          bx1    x0
          eq     wcb6a       try again
*i,pni2.1845
* /---   block      rsr/svr    00 000   81/05/27  16.05
*i,pni2.1850

          sa2    a170        see if a170 system
          nz     x2,wcbskp1  if a170 system, skip

*d,pni2.1856,bjsac.14
 wcbskp1  mx7    -21
*i,pni2.1914
* /---   block      rsr/svr    00 000   81/05/27  16.17
*d,pni2.1926,pni2.1929
*
          tx0    /plat/gfr17,ecscl release interlock
          lx0    /plat/gfrsc
          bx6    x1
          sa1    a170        see if a170 system
          nz     x1,wcb5a    skip if a170 system
*
+         re     1
          eq     *           re-try on reject

 wcb5a    bx1    x6          restore *x1*
*/ -------------------------------------------------------------------
*/ **/---   block=02-a jpoutfx              81/08/14. 13.55    source
*/ -------------------------------------------------------------------
*ident,jpoutfx
*deck,tutorx
*i,tutor1x.18
 jmpmode  equ    tbintsv+7   save jumpout mode
*d,tutor1x.32
 padjump  sx6    2           -jumpout- based on *key* value
*d,tutor1x.36
 feditx   sx6    1           -filedit-
*d,tutor1x.40,tutor1x.42
 jmpoutx  sx6    0           -jumpout-
 jpfego   sa6    jmpmode     save mode for later
*d,tutor1x.60,tutor1x.62
* /---   block      -jumpout-  00 000   81/08/14  13.47
*i,tutor1x.69
          sa1    jmpmode     get jumpout mode
          bx0    x1          restore *x0*
*d,tutor1x.83
          sa1    jmpmode     get -jumpout- mode
*i,tutorx.4405
 awvars   vfd    42/0,18/work-1
*
*
* /---   block      deffont    00 000   78/10/03  16.08
*d,varsfix.2,varsfix.5
*/ -------------------------------------------------------------------
*/ **/---   block=02-b faadev               81/08/14. 13.55    source
*/ -------------------------------------------------------------------
*ident,faadev
*/ added cyber1 and cyber2 -- gpk 04.08.23.
*/ added dtfaa             -- gpk 05.08.05.
*/ added pkoning, boris    -- gpk 06.03.28.
*deck,msubs
*d,msubsa.6,msubsa.8
 ndevsys  equ    7           maximum number of dev systems
          data   0luol       university online system
          data   0lcybdev    cybis development system
          data   0lfaa       faa system (used by uol)
          data   0ldtfaa     desktop faa system
          data   0lcyber1    cyber1.org system
          data   0lboris     second cyber1.org system
          data   0lpkoning   paul test system
*d,msubsa.15,msubsa.17
 nuolsys  equ    3           maximum number of uol systems
          data   0luol       university online system
          data   0lcybdev    cybis development system
          data   0lfaa       faa system (used by uol)
*/ -------------------------------------------------------------------
*/ **/---   block=02-c lviofix              81/10/27. 11.56    source
*/ -------------------------------------------------------------------
*ident,lviofix
*deck,autload
*d,autload.88,loadfix.3
          call   rvload
*
 lload    bss    0
          call   lvload,1    load local vars for this unit
*
          mx6    0           zero max nc vars loaded
*d,autload.441
*         called from one place in -lessons- and -filex-
*d,autload.451,autload.453
          rj     rvload
          eq     rload
*
          entry  rvload
 rvload   eq     *           entry/exit
          sa1    tbrvnum     router variables lesson number
          zr     x1,rvload
          sx2    x1          get lesson number
*d,autload.462,yulverr.1
          eq     rvload      -- exit
*
          entry  rvuload
 rvuload  eq     *           entry/exit
          sa1    tbrvnum     router variables lesson number
          zr     x1,rvuload
          sx2    x1          get lesson number
          sx3    2           bias for header
          call   lessadd
          ax1    18          get number of variables
          sb1    x1
          bx0    x7          ecs address of variables
          sa0    rvarbuf
+         we     b1          store router variables
          rj     ecsr
          eq     rvuload
*
* /---   block      lvload     00 000   81/10/26  17.14
*d,autload.471
*         called from csload, csuload, join, unjoin, dataio
*d,autload.477,autload.478
          zr     x1,lvload   if no locals
          sa2    lvucnt      number in current unit
          zr     x2,lvload1  skip chk if no lvars in unit
*d,autload.493
          sa2    lvecsad     get ecs address of lv buffer
*d,autload.539,loadfix.51
          call   rvuload
*
 luload   bss    0
          call   lvload,-1   unload local variables
*
          call   uloadcs     unload common and storage
          call   savejdg     save judge buffers (if any)
*deck,filex
*d,filex.1908
          sa2    dsnwrds     (x2) = number of words
*d,bilvars.5,bilvars.11
+         zr     x3,*+1      if first word, skip *nz* check
          ng     x3,dsiocmr  before locals, check router
+         ix3    x1+x2       (x3) = lwa +1 of transfer
          ix3    x4-x3       check if in local range
          zr     x3,dssvset  if perfect fit, go
          ng     x3,dsiocm1  beyond range of locals
 dssvset  sx6    dio.sv      reset type of i/o to sv
          sa6    dskind      locals treated same as svars
          eq     dsiochk     --- if all ok
*
* /---   block      bounds     00 000   81/10/26  07.47
 dsiocmr  sx3    rvarbuf     (x3) = fwa of router vars
*tbrvnum = 1/in-router flag,23/0,18/^$of rvars,18/rvar less^$
          sa4    tbrvnum     router var info
          ax4    18          right justify ^$ of rvars
          sx4    x4          (x4) = ^$ of rvars
*/ **/---   block=02-d lviofix              81/10/27. 11.56    source
          ix4    x3+x4       (x4) = lwa +1 of rvars
          ix3    x1-x3
+         zr     x3,*+1      if first word, skip *nz* check
          ng     x3,dsiocm1  before router, check nc
+         ix3    x1+x2       (x3) = lwa +1 of transfer
          ix3    x4-x3       check if in local range
          zr     x3,dssvset  if perfect fit, go
          pl     x3,dssvset  if in range, process as svars
*d,ncvrbuf.4
*d,filex.2230,filex.2236
 dsiow1   rj     iosetup
*d,filex.2240
          sx2    x1-dio.nc   check if to/from nc vars
          sa1    dsrel       absolute cm address
***   load *dsrel* into *x1* before checking nc vars
          zr     x2,dscmw0   --- if to/from nc vars
          sx6    lvarbuf     see if local var to store into
          ix6    x1-x6       negative if not local var
          ng     x6,dscmnlw  -- if not local var
          sa2    tlvless     load local var lesson number
          call   lvaddr      update *lvecsad* incase moved
          call   lvload,1    load local vars
          rj     iosetup
          eq     dscmw0
*
 dscmnlw  bss    0
          sx6    rvarbuf     see if router var stored into
          ix6    x1-x6       compare
          ng     x6,dscmw0   if not router var, skip
          sa2    tbrvnum     router variables lesson number
          pl     x2,dscmw0   sign bit = in-router flag
          call   rvload      load router vars
          rj     iosetup
*
 dscmw0   bss    0
*d,filex.2246
*          title  dataset disk read
*d,filexx.390,filex.2256
          rj     iosetup
*i,uznsub1.176
* /---   block      dsior      00 000   81/10/26  20.30
*d,filexx.409,filexx.410
          sa1    dsrel       absolute cm address
          eq     dscm0
*
 dsiorcm  sa1    dsrel       absolute cm address
          sx6    lvarbuf     see if local var to store into
          ix6    x1-x6       negative if not local var
          ng     x6,dscmnl   -- if not local var
          sa2    tlvless     load local var lesson number
          call   lvaddr      update *lvecsad* incase moved
          call   lvload,1    load local vars
          rj     iosetup
          eq     dscm0
*
 dscmnl   bss    0
          sx6    rvarbuf     see if router var stored into
          ix6    x1-x6       compare
          ng     x6,dscm0    if not router var, skip
          sa2    tbrvnum     router variables lesson number
          pl     x2,dscm0    sign bit = in-router flag
          call   rvload      load router vars
          rj     iosetup
*
 dscm0    bss    0
*i,filex.2279
*
          sa2    dskind      (x2) = type of datain/dataout
          sx2    x2-dio.nc   check if to/from nc/nv vars
          zr     x2,dscmu    -- if to/from nc/nv vars

***       *x1* has cm address to store into
          sx6    lvarbuf     see if local var stored into
*/ **/---   block=02-e lviofix              81/10/27. 11.57    source
          ix6    x1-x6       negative if not local var
          ng     x6,dscmnl2  -- if not local var
          call   lvload,-1   save updated local vars
          eq     dsionxt
*
 dscmnl2  bss    0
          sx6    rvarbuf     see if router var stored into
          ix6    x1-x6       negative if not router var
          ng     x6,dsionxt  -- if not router var
          sa2    tbrvnum     router variables lesson number
          pl     x2,dsionxt  sign bit = in-router flag
          call   rvuload     save updated router vars
          eq     dsionxt
*d,uqnso3.210,uqnso3.212
 dscmu    bss    0
*i,filexx.442
 iosetup  eq     *           entry/exit
          sa1    tioecs      (x1) = em address of i/o bank
          sx2    ioblth
          sa3    dsbias      offset to 1st disk buffer word
          ix0    x1+x2
          ix0    x0+x3
          sa2    dswcnt      word count
          sb2    x2
          sa1    dsrel       restore absolute cm address
          eq     iosetup     -- exit
*
*deck,logicx
*d,logicx.1565,logicx.1569
          call   lvaddr
*i,logicx.1577
***       set *lvecsad* with current local var em address
*
          entry  lvaddr
 lvaddr   eq     *           entry/exit
          ax2    18          move lesson number
          sx2    x2          strip off lesson number
          sx3    lvhead      header bias
          call   lessadd     x7 = ecs addr. of locals lesson
          sa7    =xlvecsad   store ecs address in cm cell
          eq     lvaddr      -- return
*
*
*deck,platxt
*i,platxt.1468
 lvucnt   bss    1           number of local vars this unit
 lvecsad  bss    1           ecs address of local var lesson
*
*d,ncvrbuf.27,ncvrbuf.28
*/ -------------------------------------------------------------------
*/ **/---   block=02-f filedfx              81/11/14. 12.12    source
*/ -------------------------------------------------------------------
*ident,filedfx
*deck,tutorx
*d,tutor1x.44
          bx7    -x1*x6      bit 0; 1=filedit, 0=jumpout
*/ -------------------------------------------------------------------
*/ **/---   block=02-g fgtcrsx              81/11/18. 12.13    source
*/ -------------------------------------------------------------------
*ident,fgtcrsx
*deck,exec7
*i,kytfgtx.7
          sx7    1           normal course/fine conversion
*i,kytfgtx.30
          sx7    -1          fgt course/fine conversion
*d,kytfgtx.76,kytfgtx.77
*                  *x7* has normal(1) or fgt(-1) flag
*
 touchxy  eq     *           entry/exit
          sa7    kfgt        save touch mode
*d,fgtgfix.1,fgtgfix.2
          sa1    kfgt        get touch mode
+         ng     x1,*+1      if fgt, assume in dots
          lx6    3           convert to fine grid
+         sa6    varbuf+2
*d,fgtgfix.3,fgtgfix.4
          sa1    kfgt        get touch mode
+         ng     x1,*+1      if fgt, assume in dots
          lx6    4           convert to fine grid
+         sa6    varbuf+3
*i,exec7.2041
 kfgt     bss    1           fgt mode'/ (-1=yes, 1=no)
*/ -------------------------------------------------------------------
*/ **/---   block=03-a statnfx              82/05/21. 09.02    source
*/ -------------------------------------------------------------------
*ident,statnfx
*deck,logsitx
*d,logsitx.1458,alesnam.2
          sa3    statemp+12  get *trouinf*
          sx1    x3          router lesson number
*d,logsitx.1467,logsitx.1469
          sa1    a0+1        get lesson name
 stir     bx6    x1
          sa6    a3          store name in statemp+12
*/ -------------------------------------------------------------------
*/ **/---   block=03-d date4                82/10/03. 17.05    source
*/ -------------------------------------------------------------------
*ident,date4
*deck,comnds
*d,woipc.1
          jump   8ldate4,date4,0,onestor,11010,date4x       date4    147
*deck,exec1
*d,exec1.87
          ext    copyx,jkeyx,datex,date4x,clockx
*deck,exec2
*d,exec2.33
          entry  copyx,jkeyx,datex,date4x,clockx
*d,exec2.622
 date1    sa2    iloc
*d,xkreorg.49,exec2.631
*
*
          title  -date4-
*         -date4-  (code=147)
*
*            stores the current date in y2k formast (as
*           read from nos lowcore) in specified variable.
*
 date4x   ngetvar            a1 = variable storage address
*d,exec2.635,exec2.639
          sa1    itemp+2
          eq     date1       go and save it
*
*
          title  -clock- command
*
*         -clock-  (code=137)
*
 clockx   ngetvar            a1 = variable storage address
          sx6    a1
          sa6    iloc
          call   s=tdate,itemp     read time/date
          sa1    itemp
          eq     date1       go and save it
*
*
*deck,namex
*d,namex.3151
 datime   bss    3           current time/date
*deck,recordx
*d,recordx.3966
 datime   ovdata 3           alpha time/date (3 words)
*deck,record2
*i,record2.1529
 temp2    ovdata             for *s=tdate= call
*deck,psys
*d,psys.651
*         on entry - b1 = address of three word buffer in
*i,psys.655
*                   date4= (mm/dd/yyyy)
*i,psys.683
          bx6    x7          copy date
          lx6    48          right-shift 2 character
          mx0    -6          mask for last char
          bx6    -x0*x6      mask out *tens* of system yr
          sx0    1r9         check to see if year *9x*
          bx0    x6-x0       see if year *199x*
          zr     x0,*+2      if *199x*, set to 1900
+         sx1    2r20        century 2000
          eq     *+2         skip to set century
+         sx1    2r19        century 1900
+         lx1    12          position for insertion
          bx6    x7          copy date
          lx6    54          set format '7  mm/dd/yy'7
          mx0    48
          bx6    x0*x6       mask out '7  mm/dd/  '7
          lx6    12          set format '7mm/dd/    '7
          mx0    36
          bx6    x0*x6       mask out '7mm/dd/    '7
          bx6    x6+x1       set format '7mm/dd/yy  '7
          lx7    54          set format '7--mm/dd/yy'7
          mx0    -12         mask out last 2 chars
          bx1    -x0*x7      get *yy* from original -date-
          bx6    x6+x1       set format '7mm/dd/yyyy'7
          sa6    a7+1        save in *itemp+2*
*i,psys.686
* /---   block      routines   00 000   82/10/03  16.36
*/ -------------------------------------------------------------------
*/ **/---   block=03-e cdaty2k              82/10/10. 00.00    source
*/ -------------------------------------------------------------------
*ident,cdaty2k
*deck,exec9
*i,exec9.357
* /---   block      ident      00 000   82/09/26  20.39
*d,exec9.368
*i,exec9.402
* /---   block      ident      00 000   82/09/26  20.37
*d,exec9.536
*i,exec9.541
* /---   block      ident      00 000   82/09/26  22.32
*d,exec9.615
*i,exec9.623
* /---   block      ident      00 000   82/10/07  21.49
*i,exec9.628
*         -cdate- can convert 4 types of input';
*
*         1) -day- input
*         2) -date- input
*         3) -date4- input
*         4) month, day, year input
*                yr = 70-99 (1970-1999)
*                     00-69 (2000-2069)
*                     100-199 (2000-2099)
*                     1970-2069
*
*d,exec9.658
          ng     x4,dalpha   alpha format input (date)
          bx1    x4          copy value
          lx1    6           shift 1st char right side
          mx0    -6          mask first char
          bx1    -x0*x1      get first char (right side)
          sx0    1r0         see if first char ',0',
          bx0    x0-x1       compare
          zr     x0,dalpha   -date4- format
          sx0    1r1         see if first char ',1',
          bx0    x0-x1       compare
          zr     x0,dalpha   -date4- format
*d,exec9.667,exec9.670
          sb1    3
          eq     b1,b3,nolzero  if yy/mm/dd..
          sb1    6
          eq     b1,b3,nolzero  if yyyy/mm/dd

          mx3    6           check for leading zero
          bx3    x7*x3       mask out first character
          lx3    6           right justify character
          sx1    33b         ',0',
          ix3    x3-x1       compare
          nz     x3,nolzero
*i,exec9.679
* /---   block      ident      00 000   82/10/09  20.40
*d,exec9.688
*i,exec9.746
* /---   block      ident      00 000   82/10/09  20.40
*d,exec9.752
*d,exec9.758
          sb3    x1          (b1) = format 1-6
*d,exec9.766
          sb1    6           1-3 regular, 4-6 y2k
*i,exec9.778
* /---   block      ident      00 000   82/10/09  22.10
*d,exec9.806,exec9.811
          ng     x1,err0     leave if < 0

*d,exec9.822,exec9.834

**        comment out lines below to solve year 2000
**        leap year problem.    10/09/98 cmh
*          bx3    x0
*          bx4    x1
**         ix2    x4/x3       form partial year
*          px4    x4
*          px3    x3
*          nx4    x4,b4
*          nx3    x3,b4
*          fx2    x4/x3
*          ux2    x2,b4
*          lx2    b4
*          ix0    x0*x2
*          ix1    x1-x0       (jul * 4)-1-(146097 * year)
**        above lines commented out because checking for
**        leap year in year 2000 does not compute correctly.
*/ **/---   block=03-f cdaty2k              82/10/10. 22.19    source
**        this will have to be fixed further before year
**        2100 to prevent leap year.  10/09/98 cmh

*i,exec9.862
* /---   block      ident      00 000   82/10/09  23.27
*d,exec9.894
*d,exec9.898,exec9.900

*          sx0    100
*          ix2    x0*x2       year*100
*          ix2    x2+x1       year _ year*100+jul
**        above 3 lines commented out because removing
**        check for 146097 check on day/month automatically
**        adds 100 to the year.   10/09/98 cmh
          bx2    x1          get year (10/10/98 cmh)
*i,exec9.915


* /---   block      ident      00 000   82/10/09  23.58
*d,exec9.943,exec9.944
          sa1    datesl      10h00/00/0000
          bx6    x1

          sx1    2000        check to see if date < 2000
          ix1    x2-x1       compare
          ng     x1,dpack00  if negative, year 1900+
          sx2    x1          convert to 2 digit year
          eq     dpack02

 dpack00  sx0    2r19        year 19xx
          sx1    1900d       see if 4 digit year
          ix1    x2-x1       compare
          ng     x1,*+2      if < 1900, continue
+         sx2    x1          get 2 digit year
          eq     dpack03

+         sx1    100         check to see if > 100 (yr 2000)
          ix1    x2-x1       compare
          ng     x1,dpack01  if < 100, year 1900
          bx2    x1          get 2 digit year
          eq     dpack02

 dpack01  sx1    72          check to see if 2char date
          ix1    x2-x1       compare
          pl     x1,dpack03  year in 1900 century
 dpack02  sx0    2r20        set thousands/hundreds
 dpack03  lx0    12          position for insert
          mx1    12          set up mask to clear century
          lx1    24          position correctly
          bx6    -x1*x6      00/00/..00
          bx6    x6+x0       (x6) = 00/00/xx00
*d,exec9.950
*d,exec9.957
          lx0    30
*d,exec9.964
          lx0    48
*i,exec9.967
* /---   block      ident      00 000   82/10/09  20.05
*d,exec9.973
*d,exec9.997,exec9.1003
          pl     x1,datcvt1  if in y2k format, skip
          lx1    6           (x1) = mm/dd/yy--
          mx0    12          mask out year to move
          lx0    24          position to *yy*
          bx4    x0*x1       get *yy*
          lx4    48          right justify *yy*
          mx0    6*6         6 chars
          bx1    x0*x1       (x1) = mm/dd/....
          bx2    x4          copy *yy*
          ax2    6           right shift, drop ones digit
          sx3    1r7         check for year 1970 or greater
          ix3    x2-x3       check to see if 1970 or greater
          pl     x3,*+2      if 1970 or greater, skip
+         sx0    2r20        set to year 20xx
          eq     *+2
*/ **/---   block=03-g cdaty2k              82/10/10. 12.36    source
+         sx0    2r19        set to year 19xx
+         lx0    12          position century for date
          bx1    x1+x0       (x1) = mm/dd/xx00
          bx1    x1+x4       (x1) = mm/dd/xxyy

 datcvt1  sb1    1           format 1
          eq     b1,b3,dshif1
          sb1    4           y2k form of format 1
          eq     b1,b3,dshif1

          sb1    2           format 2
          eq     b1,b3,ddmmyy
          sb1    5           y2k form of format 2
          eq     b1,b3,ddmmyy

* /---   block      ident      00 000   82/10/09  20.00
*d,exec9.1007,exec9.1017
          bx2    x1*x4       mm/dd.....
          lx2    42          ...mm/dd..
          mx4    -4*6        777777....
          bx3    -x4*x1      ......yyyy
          lx3    48          yy......yy
          sx4    1r/         ........./
          lx4    42          ../.......

          sb1    6           y2k format
          eq     b1,b3,ydm1  if y2k format
          mx0    12          mask top 2 chars
          bx3    x0*x3       (yy........)
          eq     ydm2

 ydm1     lx2    48          .....mm/dd
          lx3    48          yyyy......
          lx4    48          ..../.....

 ydm2     bx7    x3+x4       yy/....... or yyyyy/.....
          bx7    x7+x2       yy/mm/dd.. or yyyy/mm/dd
*d,exec9.1022,exec9.1046
 ddmmyy   mx0    -4*6        777777....
          bx7    -x0*x1      ......yyyy

          sb1    5           y2k format
          eq     b1,b3,*+2   if y2k format

+         mx0    -12
          bx7    -x0*x7      ........yy
          lx7    12          ......yy..

+         mx0    3*6         777....... (2 chars of 77b)
          bx2    x1*x0       mm/.......
          lx2    42          ...mm/...
          lx1    18          dd/yyyymm/
          bx3    x0*x1       dd/.......
          bx7    x7+x3       dd/...yy.. or dd/...yyyy
          bx7    x7+x2       dd/mm/yy.. or dd/mm/yyyy
          eq     datcvt      exit


 dshif1   bx7    x1          (mm/dd/yyyy)
          sb1    4           y2k format
          eq     b1,b3,datcvt   already in y2k, exit

          mx0    8*6         77777777..
          bx3    -x0*x1      mask out 2 digit year
          mx0    6*6         777777....
          bx7    x1*x0       mm/dd/....
          lx3    12          ......yy..
          bx7    x7+x3       mm/dd/yy..
          eq     datcvt      exit
* /---   block      ident      00 000   82/10/03  18.35
*d,exec9.1079,exec9.1081
          sb1    3           format 3
          ne     b1,b3,dshf0 year is on left now
          lx1    3*6         move year to right side
          eq     dshf

*/ **/---   block=04-a cdaty2k              82/10/10. 12.36    source
 dshf0    sb1    6           y2k form of format 3
          ne     b1,b3,dshf  year is on left now
          lx7    5*6         move the year to right

*i,exec9.1084


*d,exec9.1117,exec9.1118
 datesl   con    10h00/00/0000
*/ -------------------------------------------------------------------
*/ **/---   block=04-c buy2k                83/02/20. 12.28    source
*/ -------------------------------------------------------------------
*ident,buy2k
*deck,backlib
*i,backlib.159
* /---   block      tape       00 000   82/10/20  21.37
*
*d,bufix.1,backlib.165
          sx1    x1+96d      current year = yr+96 (base yr)
          sx7    100d        see if past (19)99
          ix7    x1-x7       subtract 100, + = year 20xx
          ng     x7,buildo1  if negative, not year 2000+
          sx1    x7          get 2 digit portion of yr 2000
 buildo1  rj     cdd
*deck,backone
*i,backone.341
* /---   block      backone    00 000   82/10/20  21.49
*
*d,backone.346,backone.347
          sx1    x1+96d      (current year = yr+96)
          sx7    100d        see if past (19)99
          ix7    x1-x7       subtract 100, + = year 20xx
          ng     x7,buildo1  if negative, not year 2000+
          sx1    x7          get 2 digit portion of yr 2000
 buildo1  rj     cdd
*deck,copymf
*i,copymf.247
 setepr   space  4
**        setepr - set error processing bit in the fet
*
*         entry  a1/x1=fet+1 and contents

 setepr   data   0           entry/exit
          sx6    b1          mask for epr
          lx6    44
          bx6    x6+x1
          sa6    a1
          eq     setepr
* /---   block      subrtines  00 000   82/10/20  21.26
*d,bufix.1
** in packed date, the year is stored in 12 bits, full
** value (ie'; 1998).  'i assume it is already y2k
** compliant so will have a value of 2000 and beyond.
** below, it subtracts 26d from year (1998), then masks
** the lower 4 bits to come up with the offset.  'the
** original offset was 13d (1980-1995), but with a
** modification, was changed to 26d to handle years
** 1996-2011.  'a bit used in another word is used as a
** flag to indicate the field is using the new format
** (see mods made to deck '7backone'7 to see how flag set).
** for example'; 1998-26=1972 (o3664), o3664 $mask$ o17
** (4 bits) = 4.     cmh 10/20/98
          sx5    26d         subtract 26 years (1996 base)
*d,copymf.297,copymf.308
*deck,copypf
*i,copypf.1317
* /---   block      copypfx    00 000   82/10/20  21.55
*
*d,copypf.1322,copypf.1323
          sx1    x1+96d      (current year = yr+96)
          sx7    100d        see if past (19)99
          ix7    x1-x7       subtract 100, + = year 20xx
          ng     x7,buildo1  if negative, not year 2000+
          sx1    x7          get 2 digit portion of yr 2000
 buildo1  rj     cdd
*/ -------------------------------------------------------------------
*/ **/---   block=04-f datinfx              86/01/30. 20.25    source
*/ -------------------------------------------------------------------
*ident,datinfx
*deck,filex
*d,uznsubf.140
*d,filexx.428
 dserr2x  sx6    2           2 = bad record number
*d,uznsub1.265,uznsub1.268
          ng     x6,dserr2x  --- error if bad record number
          mx2    -18         check if too big
          bx2    x2*x1
          nz     x2,dserr2x  --- error if bad record number
*deck,exec1
*d,exec1.2221
*         uses a/0,4
*d,exec1.2225,rewefx2.1
          sx0    x4          unit info only
          sa4    ecsuloc     get address of -uloc- table
          ix0    x4+x0       index to this unit
*deck,filex
*d,filexx.565
          sa1    ilesun      load lesson number
          bx5    x1          move it to *x5*
*deck,ioput
*i,ioput.1998
          sa5    a5          restore *x5* incase lost
*/ -------------------------------------------------------------------
~
;;; Local Variables: ***
;;; mode:Update ***
;;; End: ***
